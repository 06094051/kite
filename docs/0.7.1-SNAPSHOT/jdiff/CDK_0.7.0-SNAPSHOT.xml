<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Tue Sep 10 15:08:57 BST 2013 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="CDK 0.7.0-SNAPSHOT"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /Users/tom/workspace/cdk/lib/jdiff.jar -classpath /Users/tom/workspace/cdk/target/classes:/Users/tom/workspace/cdk/cdk-data/target/classes:/Users/tom/workspace/cdk/cdk-data/cdk-data-core/target/classes:/Users/tom/workspace/cdk/cdk-data/cdk-data-crunch/target/classes:/Users/tom/workspace/cdk/cdk-data/cdk-data-flume/target/classes:/Users/tom/workspace/cdk/cdk-data/cdk-data-hcatalog/target/classes:/Users/tom/workspace/cdk/cdk-data/cdk-data-hbase/target/classes:/Users/tom/workspace/cdk/cdk-flume-avro-event-serializer/target/classes:/Users/tom/workspace/cdk/cdk-maven-plugin/target/classes:/Users/tom/workspace/cdk/cdk-tools/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-core/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-avro/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-json/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-saxon/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-tika-core/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-tika-decompress/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-twitter/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-hadoop-sequencefile/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-solr-core/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-solr-cell/target/classes:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-all/target/classes:/Users/tom/.m2/repository/org/apache/hcatalog/hcatalog-core/0.5.0-cdh4.3.0/hcatalog-core-0.5.0-cdh4.3.0.jar:/Users/tom/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/Users/tom/.m2/repository/org/antlr/stringtemplate/3.2.1/stringtemplate-3.2.1.jar:/Users/tom/.m2/repository/com/twitter/parquet-generator/1.0.0/parquet-generator-1.0.0.jar:/Users/tom/.m2/repository/com/sun/jersey/jersey-json/1.8/jersey-json-1.8.jar:/Users/tom/.m2/repository/commons-net/commons-net/3.1/commons-net-3.1.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-yarn-server-common/2.0.0-cdh4.3.0/hadoop-yarn-server-common-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-hs/2.0.0-cdh4.3.0/hadoop-mapreduce-client-hs-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-morphlines-tika-core/0.7.0-SNAPSHOT/cdk-morphlines-tika-core-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/classworlds/classworlds/1.1-alpha-2/classworlds-1.1-alpha-2.jar:/Users/tom/.m2/repository/org/codehaus/plexus/plexus-utils/3.0/plexus-utils-3.0.jar:/Users/tom/.m2/repository/antlr/antlr/2.7.7/antlr-2.7.7.jar:/Users/tom/.m2/repository/org/apache/hive/hive-builtins/0.10.0-cdh4.3.0/hive-builtins-0.10.0-cdh4.3.0.jar:/Users/tom/.m2/repository/commons-configuration/commons-configuration/1.6/commons-configuration-1.6.jar:/Users/tom/.m2/repository/commons-pool/commons-pool/1.5.4/commons-pool-1.5.4.jar:/Users/tom/.m2/repository/org/apache/solr/solr-core/4.4.0/solr-core-4.4.0.jar:/Users/tom/.m2/repository/org/ccil/cowan/tagsoup/tagsoup/1.2.1/tagsoup-1.2.1.jar:/Users/tom/.m2/repository/com/googlecode/javaewah/JavaEWAH/0.3.2/JavaEWAH-0.3.2.jar:/Users/tom/.m2/repository/com/twitter/parquet-column/1.0.0/parquet-column-1.0.0.jar:/Users/tom/.m2/repository/org/apache/hbase/hbase/0.94.6-cdh4.3.0/hbase-0.94.6-cdh4.3.0-tests.jar:/Users/tom/.m2/repository/org/apache/maven/maven-repository-metadata/2.0.6/maven-repository-metadata-2.0.6.jar:/Users/tom/.m2/repository/org/apache/james/apache-mime4j-dom/0.7.2/apache-mime4j-dom-0.7.2.jar:/Users/tom/.m2/repository/org/apache/httpcomponents/httpclient/4.2.3/httpclient-4.2.3.jar:/Users/tom/.m2/repository/com/linkedin/haivvreo/1.0.7-cdh-4/haivvreo-1.0.7-cdh-4.jar:/Users/tom/.m2/repository/org/apache/hive/hive-serde/0.10.0-cdh4.3.0/hive-serde-0.10.0-cdh4.3.0.jar:/Users/tom/.m2/repository/com/sun/jersey/jersey-client/1.8/jersey-client-1.8.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-spatial/4.4.0/lucene-spatial-4.4.0.jar:/Users/tom/.m2/repository/com/googlecode/concurrentlinkedhashmap/concurrentlinkedhashmap-lru/1.2/concurrentlinkedhashmap-lru-1.2.jar:/Users/tom/.m2/repository/org/apache/velocity/velocity/1.7/velocity-1.7.jar:/Users/tom/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/Users/tom/.m2/repository/org/apache/maven/maven-plugin-api/2.0.6/maven-plugin-api-2.0.6.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-yarn-client/2.0.0-cdh4.3.0/hadoop-yarn-client-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/joda-time/joda-time/2.2/joda-time-2.2.jar:/Users/tom/.m2/repository/org/apache/httpcomponents/httpmime/4.2.3/httpmime-4.2.3.jar:/Users/tom/.m2/repository/jdom/jdom/1.0/jdom-1.0.jar:/Users/tom/.m2/repository/org/apache/maven/maven-core/3.0/maven-core-3.0.jar:/Users/tom/.m2/repository/javax/xml/bind/jaxb-api/2.2.2/jaxb-api-2.2.2.jar:/Users/tom/.m2/repository/com/sun/jersey/jersey-core/1.8/jersey-core-1.8.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-data-hcatalog/0.7.0-SNAPSHOT/cdk-data-hcatalog-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/org/apache/poi/poi-scratchpad/3.8/poi-scratchpad-3.8.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-yarn-common/2.0.0-cdh4.3.0/hadoop-yarn-common-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/xerial/snappy/snappy-java/1.0.5/snappy-java-1.0.5.jar:/Users/tom/.m2/repository/commons-collections/commons-collections/3.2.1/commons-collections-3.2.1.jar:/Users/tom/.m2/repository/org/antlr/ST4/4.0.4/ST4-4.0.4.jar:/Users/tom/.m2/repository/commons-daemon/commons-daemon/1.0.3/commons-daemon-1.0.3.jar:/Users/tom/.m2/repository/dom4j/dom4j/1.6.1/dom4j-1.6.1.jar:/Users/tom/.m2/repository/org/apache/poi/poi-ooxml-schemas/3.8/poi-ooxml-schemas-3.8.jar:/Users/tom/.m2/repository/com/google/guava/guava/11.0.2/guava-11.0.2.jar:/Users/tom/.m2/repository/org/datanucleus/datanucleus-core/2.0.3/datanucleus-core-2.0.3.jar:/Users/tom/.m2/repository/com/twitter/parquet-encoding/1.0.0/parquet-encoding-1.0.0.jar:/Users/tom/.m2/repository/javax/activation/activation/1.1/activation-1.1.jar:/Users/tom/.m2/repository/org/apache/tika/tika-core/1.3/tika-core-1.3.jar:/Users/tom/.m2/repository/org/sonatype/aether/aether-impl/1.7/aether-impl-1.7.jar:/Users/tom/.m2/repository/org/glassfish/grizzly/grizzly-rcm/2.1.1/grizzly-rcm-2.1.1.jar:/Users/tom/.m2/repository/com/adobe/xmp/xmpcore/5.1.2/xmpcore-5.1.2.jar:/Users/tom/.m2/repository/org/codehaus/jackson/jackson-jaxrs/1.8.8/jackson-jaxrs-1.8.8.jar:/Users/tom/.m2/repository/org/codehaus/jettison/jettison/1.1/jettison-1.1.jar:/Users/tom/.m2/repository/net/sf/kosmosfs/kfs/0.3/kfs-0.3.jar:/Users/tom/.m2/repository/net/sf/saxon/Saxon-HE/9.5.1-1/Saxon-HE-9.5.1-1.jar:/Users/tom/.m2/repository/com/google/protobuf/protobuf-java/2.4.0a/protobuf-java-2.4.0a.jar:/Users/tom/.m2/repository/org/antlr/antlr-runtime/3.4/antlr-runtime-3.4.jar:/Users/tom/.m2/repository/com/sun/jersey/jersey-server/1.8/jersey-server-1.8.jar:/Users/tom/.m2/repository/org/noggit/noggit/0.5/noggit-0.5.jar:/Users/tom/.m2/repository/com/twitter/parquet-common/1.0.0/parquet-common-1.0.0.jar:/Users/tom/.m2/repository/org/apache/avro/trevni-avro/1.7.4/trevni-avro-1.7.4.jar:/Users/tom/.m2/repository/org/slf4j/slf4j-simple/1.6.1/slf4j-simple-1.6.1.jar:/Users/tom/.m2/repository/com/typesafe/config/1.0.2/config-1.0.2.jar:/Users/tom/.m2/repository/org/mortbay/jetty/jetty/6.1.26.cloudera.2/jetty-6.1.26.cloudera.2.jar:/Users/tom/.m2/repository/org/restlet/jee/org.restlet.ext.servlet/2.1.1/org.restlet.ext.servlet-2.1.1.jar:/Users/tom/.m2/repository/org/eclipse/jdt/core/3.1.1/core-3.1.1.jar:/Users/tom/.m2/repository/org/glassfish/external/management-api/3.0.0-b012/management-api-3.0.0-b012.jar:/Users/tom/.m2/repository/com/spatial4j/spatial4j/0.3/spatial4j-0.3.jar:/Users/tom/.m2/repository/log4j/log4j/1.2.16/log4j-1.2.16.jar:/Users/tom/.m2/repository/org/codehaus/plexus/plexus-container-default/1.0-alpha-9-stable-1/plexus-container-default-1.0-alpha-9-stable-1.jar:/Users/tom/.m2/repository/org/codehaus/plexus/plexus-classworlds/2.2.3/plexus-classworlds-2.2.3.jar:/Users/tom/.m2/repository/org/apache/avro/avro-ipc/1.7.4/avro-ipc-1.7.4-tests.jar:/Users/tom/.m2/repository/org/apache/hive/hive-exec/0.10.0-cdh4.3.0/hive-exec-0.10.0-cdh4.3.0.jar:/Users/tom/.m2/repository/com/googlecode/juniversalchardet/juniversalchardet/1.0.3/juniversalchardet-1.0.3.jar:/Users/tom/.m2/repository/org/sonatype/aether/aether-spi/1.7/aether-spi-1.7.jar:/Users/tom/.m2/repository/org/apache/ftpserver/ftpserver-deprecated/1.0.0-M2/ftpserver-deprecated-1.0.0-M2.jar:/Users/tom/.m2/repository/org/apache/maven/maven-settings/2.0.6/maven-settings-2.0.6.jar:/Users/tom/.m2/repository/com/sun/jersey/jersey-test-framework/jersey-test-framework-core/1.8/jersey-test-framework-core-1.8.jar:/Users/tom/.m2/repository/org/apache/maven/wagon/wagon-provider-api/1.0-beta-2/wagon-provider-api-1.0-beta-2.jar:/Users/tom/.m2/repository/commons-fileupload/commons-fileupload/1.2.1/commons-fileupload-1.2.1.jar:/Users/tom/.m2/repository/org/slf4j/jcl-over-slf4j/1.6.1/jcl-over-slf4j-1.6.1.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-yarn-server-tests/2.0.0-cdh4.3.0/hadoop-yarn-server-tests-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/mortbay/jetty/jsp-2.1/6.1.14/jsp-2.1-6.1.14.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-yarn-server-resourcemanager/2.0.0-cdh4.3.0/hadoop-yarn-server-resourcemanager-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/tika/tika-xmp/1.3/tika-xmp-1.3.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-core/4.4.0/lucene-core-4.4.0.jar:/Users/tom/.m2/repository/commons-el/commons-el/1.0/commons-el-1.0.jar:/Users/tom/.m2/repository/jline/jline/0.9.94/jline-0.9.94.jar:/Users/tom/.m2/repository/org/apache/pdfbox/jempbox/1.7.1/jempbox-1.7.1.jar:/Users/tom/.m2/repository/org/bouncycastle/bcmail-jdk15/1.45/bcmail-jdk15-1.45.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-yarn-server-nodemanager/2.0.0-cdh4.3.0/hadoop-yarn-server-nodemanager-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/avro/trevni-core/1.7.4/trevni-core-1.7.4.jar:/Users/tom/.m2/repository/org/jruby/jruby-complete/1.6.5/jruby-complete-1.6.5.jar:/Users/tom/.m2/repository/org/jboss/netty/netty/3.2.4.Final/netty-3.2.4.Final.jar:/Users/tom/.m2/repository/commons-beanutils/commons-beanutils-core/1.8.0/commons-beanutils-core-1.8.0.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-morphlines-tika-decompress/0.7.0-SNAPSHOT/cdk-morphlines-tika-decompress-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-morphlines-core/0.7.0-SNAPSHOT/cdk-morphlines-core-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/org/apache/hive/hive-cli/0.10.0-cdh4.3.0/hive-cli-0.10.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/maven/plugin-tools/maven-plugin-annotations/3.1/maven-plugin-annotations-3.1.jar:/Users/tom/.m2/repository/org/apache/flume/flume-ng-configuration/1.3.0-cdh4.3.0/flume-ng-configuration-1.3.0-cdh4.3.0.jar:/Users/tom/.m2/repository/de/l3s/boilerpipe/boilerpipe/1.1.0/boilerpipe-1.1.0.jar:/Users/tom/.m2/repository/org/apache/thrift/libfb303/0.9.0/libfb303-0.9.0.jar:/Users/tom/.m2/repository/com/googlecode/mp4parser/isoparser/1.0-RC-1/isoparser-1.0-RC-1.jar:/Users/tom/.m2/repository/org/apache/avro/avro-mapred/1.7.4/avro-mapred-1.7.4-hadoop2.jar:/Users/tom/.m2/repository/org/apache/pdfbox/pdfbox/1.7.1/pdfbox-1.7.1.jar:/Users/tom/.m2/repository/org/apache/hive/hive-service/0.10.0-cdh4.3.0/hive-service-0.10.0-cdh4.3.0.jar:/Users/tom/.m2/repository/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-memory/4.4.0/lucene-memory-4.4.0.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-jobclient/2.0.0-cdh4.3.0/hadoop-mapreduce-client-jobclient-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/commons-io/commons-io/2.1/commons-io-2.1.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-morphlines-saxon/0.7.0-SNAPSHOT/cdk-morphlines-saxon-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/tomcat/jasper-runtime/5.5.23/jasper-runtime-5.5.23.jar:/Users/tom/.m2/repository/org/apache/solr/solr-cell/4.4.0/solr-cell-4.4.0.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-archives/2.0.0-cdh4.3.0/hadoop-archives-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/gagravarr/vorbis-java-core/0.1/vorbis-java-core-0.1.jar:/Users/tom/.m2/repository/org/apache/xmlbeans/xmlbeans/2.3.0/xmlbeans-2.3.0.jar:/Users/tom/.m2/repository/commons-logging/commons-logging-api/1.1/commons-logging-api-1.1.jar:/Users/tom/.m2/repository/org/apache/avro/avro/1.7.5/avro-1.7.5.jar:/Users/tom/.m2/repository/org/apache/hive/hive-contrib/0.10.0-cdh4.3.0/hive-contrib-0.10.0-cdh4.3.0.jar:/Users/tom/.m2/repository/hsqldb/hsqldb/1.8.0.10/hsqldb-1.8.0.10.jar:/Users/tom/.m2/repository/org/apache/maven/maven-settings-builder/3.0/maven-settings-builder-3.0.jar:/Users/tom/.m2/repository/org/apache/hive/hive-shims/0.10.0-cdh4.3.0/hive-shims-0.10.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/json/json/20090211/json-20090211.jar:/Users/tom/.m2/repository/org/apache/maven/maven-plugin-registry/2.0.6/maven-plugin-registry-2.0.6.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-core/2.0.0-cdh4.3.0/hadoop-mapreduce-client-core-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/sonatype/aether/aether-util/1.7/aether-util-1.7.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-app/2.0.0-cdh4.3.0/hadoop-mapreduce-client-app-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/tomcat/jasper-compiler/5.5.23/jasper-compiler-5.5.23.jar:/Users/tom/.m2/repository/org/datanucleus/datanucleus-connectionpool/2.0.3/datanucleus-connectionpool-2.0.3.jar:/Users/tom/.m2/repository/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5.jar:/Users/tom/.m2/repository/org/glassfish/grizzly/grizzly-http-server/2.1.1/grizzly-http-server-2.1.1.jar:/Users/tom/.m2/repository/org/glassfish/grizzly/grizzly-framework/2.1.1/grizzly-framework-2.1.1-tests.jar:/Users/tom/.m2/repository/commons-codec/commons-codec/1.4/commons-codec-1.4.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-client/2.0.0-mr1-cdh4.3.0/hadoop-client-2.0.0-mr1-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/zookeeper/zookeeper/3.4.5-cdh4.3.0/zookeeper-3.4.5-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-minicluster/2.0.0-mr1-cdh4.3.0/hadoop-minicluster-2.0.0-mr1-cdh4.3.0.jar:/Users/tom/.m2/repository/org/gagravarr/vorbis-java-tika/0.1/vorbis-java-tika-0.1.jar:/Users/tom/.m2/repository/org/glassfish/grizzly/grizzly-http-servlet/2.1.1/grizzly-http-servlet-2.1.1.jar:/Users/tom/.m2/repository/com/google/inject/guice/3.0/guice-3.0.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-morphlines-twitter/0.7.0-SNAPSHOT/cdk-morphlines-twitter-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/org/datanucleus/datanucleus-rdbms/2.0.3/datanucleus-rdbms-2.0.3.jar:/Users/tom/.m2/repository/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.jar:/Users/tom/.m2/repository/com/twitter/parquet-format/1.0.0/parquet-format-1.0.0.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-annotations/2.0.5-alpha/hadoop-annotations-2.0.5-alpha.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-analyzers-kuromoji/4.4.0/lucene-analyzers-kuromoji-4.4.0.jar:/Users/tom/.m2/repository/org/apache/thrift/libthrift/0.9.0/libthrift-0.9.0.jar:/Users/tom/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/Users/tom/.m2/repository/com/google/inject/extensions/guice-servlet/3.0/guice-servlet-3.0.jar:/Users/tom/.m2/repository/org/apache/maven/maven-model/2.0.6/maven-model-2.0.6.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-morphlines-hadoop-sequencefile/0.7.0-SNAPSHOT/cdk-morphlines-hadoop-sequencefile-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-suggest/4.4.0/lucene-suggest-4.4.0.jar:/Users/tom/.m2/repository/org/apache/maven/maven-profile/2.0.6/maven-profile-2.0.6.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-morphlines-avro/0.7.0-SNAPSHOT/cdk-morphlines-avro-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/org/apache/ftpserver/ftpserver-core/1.0.0/ftpserver-core-1.0.0.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-morphlines-json/0.7.0-SNAPSHOT/cdk-morphlines-json-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/org/sonatype/sisu/sisu-guice/2.1.7/sisu-guice-2.1.7-noaop.jar:/Users/tom/.m2/repository/javax/jdo/jdo2-api/2.3-ec/jdo2-api-2.3-ec.jar:/Users/tom/.m2/repository/javax/servlet/jsp/jsp-api/2.1/jsp-api-2.1.jar:/Users/tom/.m2/repository/javax/servlet/servlet-api/2.5/servlet-api-2.5.jar:/Users/tom/.m2/repository/org/apache/mina/mina-core/2.0.4/mina-core-2.0.4.jar:/Users/tom/.m2/repository/org/jamon/jamon-runtime/2.3.1/jamon-runtime-2.3.1.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-test/2.0.0-mr1-cdh4.3.0/hadoop-test-2.0.0-mr1-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/tika/tika-parsers/1.3/tika-parsers-1.3.jar:/Users/tom/.m2/repository/org/glassfish/grizzly/grizzly-http/2.1.1/grizzly-http-2.1.1.jar:/Users/tom/.m2/repository/commons-dbcp/commons-dbcp/1.4/commons-dbcp-1.4.jar:/Users/tom/.m2/repository/com/twitter/parquet-avro/1.0.0/parquet-avro-1.0.0.jar:/Users/tom/.m2/repository/com/sun/jersey/contribs/jersey-guice/1.8/jersey-guice-1.8.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-analyzers-common/4.4.0/lucene-analyzers-common-4.4.0.jar:/Users/tom/.m2/repository/org/slf4j/slf4j-log4j12/1.6.1/slf4j-log4j12-1.6.1.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-codecs/4.4.0/lucene-codecs-4.4.0.jar:/Users/tom/.m2/repository/com/jcraft/jsch/0.1.42/jsch-0.1.42.jar:/Users/tom/.m2/repository/org/apache/flume/flume-ng-sdk/1.3.0-cdh4.3.0/flume-ng-sdk-1.3.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-misc/4.4.0/lucene-misc-4.4.0.jar:/Users/tom/.m2/repository/org/apache/solr/solr-solrj/4.4.0/solr-solrj-4.4.0.jar:/Users/tom/.m2/repository/commons-lang/commons-lang/2.6/commons-lang-2.6.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-common/2.0.5-alpha/hadoop-common-2.0.5-alpha.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-data-core/0.7.0-SNAPSHOT/cdk-data-core-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-common/2.0.0-cdh4.3.0/hadoop-mapreduce-client-common-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/commons/commons-math/2.1/commons-math-2.1.jar:/Users/tom/.m2/repository/org/apache/httpcomponents/httpcore/4.2.2/httpcore-4.2.2.jar:/Users/tom/.m2/repository/org/apache/maven/maven-model-builder/3.0/maven-model-builder-3.0.jar:/Users/tom/.m2/repository/org/apache/poi/poi/3.8/poi-3.8.jar:/Users/tom/.m2/repository/org/apache/maven/maven-project/2.0.6/maven-project-2.0.6.jar:/Users/tom/.m2/repository/com/fasterxml/jackson/core/jackson-annotations/2.2.1/jackson-annotations-2.2.1.jar:/Users/tom/.m2/repository/org/sonatype/sisu/sisu-inject-bean/1.4.2/sisu-inject-bean-1.4.2.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-shuffle/2.0.0-cdh4.3.0/hadoop-mapreduce-client-shuffle-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-core/2.0.0-mr1-cdh4.3.0/hadoop-core-2.0.0-mr1-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/ftpserver/ftplet-api/1.0.0/ftplet-api-1.0.0.jar:/Users/tom/.m2/repository/org/tukaani/xz/1.0/xz-1.0.jar:/Users/tom/.m2/repository/org/mortbay/jetty/servlet-api-2.5/6.1.14/servlet-api-2.5-6.1.14.jar:/Users/tom/.m2/repository/org/apache/hbase/hbase/0.94.6-cdh4.3.0/hbase-0.94.6-cdh4.3.0.jar:/Users/tom/.m2/repository/stax/stax-api/1.0.1/stax-api-1.0.1.jar:/Users/tom/.m2/repository/com/twitter/parquet-hadoop/1.0.0/parquet-hadoop-1.0.0.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-morphlines-solr-core/0.7.0-SNAPSHOT/cdk-morphlines-solr-core-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-highlighter/4.4.0/lucene-highlighter-4.4.0.jar:/Users/tom/.m2/repository/org/apache/maven/maven-artifact-manager/2.0.6/maven-artifact-manager-2.0.6.jar:/Users/tom/.m2/repository/org/apache/commons/commons-compress/1.4.1/commons-compress-1.4.1.jar:/Users/tom/.m2/repository/org/bouncycastle/bcprov-jdk15/1.45/bcprov-jdk15-1.45.jar:/Users/tom/.m2/repository/org/codehaus/plexus/plexus-interpolation/1.14/plexus-interpolation-1.14.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-queryparser/4.4.0/lucene-queryparser-4.4.0.jar:/Users/tom/.m2/repository/io/netty/netty/3.4.0.Final/netty-3.4.0.Final.jar:/Users/tom/.m2/repository/com/github/stephenc/high-scale-lib/high-scale-lib/1.1.1/high-scale-lib-1.1.1.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-grouping/4.4.0/lucene-grouping-4.4.0.jar:/Users/tom/.m2/repository/org/sonatype/sisu/sisu-inject-plexus/1.4.2/sisu-inject-plexus-1.4.2.jar:/Users/tom/.m2/repository/org/apache/avro/avro-mapred/1.7.4/avro-mapred-1.7.4.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-analyzers-phonetic/4.4.0/lucene-analyzers-phonetic-4.4.0.jar:/Users/tom/.m2/repository/com/drewnoakes/metadata-extractor/2.6.2/metadata-extractor-2.6.2.jar:/Users/tom/.m2/repository/javax/transaction/jta/1.1/jta-1.1.jar:/Users/tom/.m2/repository/org/apache/hive/hive-common/0.10.0-cdh4.3.0/hive-common-0.10.0-cdh4.3.0.jar:/Users/tom/.m2/repository/com/google/code/gson/gson/2.2.2/gson-2.2.2.jar:/Users/tom/.m2/repository/org/datanucleus/datanucleus-enhancer/2.0.3/datanucleus-enhancer-2.0.3.jar:/Users/tom/.m2/repository/org/aspectj/aspectjrt/1.6.11/aspectjrt-1.6.11.jar:/Users/tom/.m2/repository/org/apache/james/apache-mime4j-core/0.7.2/apache-mime4j-core-0.7.2.jar:/Users/tom/.m2/repository/org/sonatype/plexus/plexus-sec-dispatcher/1.3/plexus-sec-dispatcher-1.3.jar:/Users/tom/.m2/repository/com/sun/jersey/jersey-grizzly2/1.8/jersey-grizzly2-1.8.jar:/Users/tom/.m2/repository/org/apache/poi/poi-ooxml/3.8/poi-ooxml-3.8.jar:/Users/tom/.m2/repository/org/mortbay/jetty/servlet-api/2.5-20110124/servlet-api-2.5-20110124.jar:/Users/tom/.m2/repository/org/apache/pdfbox/fontbox/1.7.1/fontbox-1.7.1.jar:/Users/tom/.m2/repository/org/apache/avro/avro-ipc/1.7.4/avro-ipc-1.7.4.jar:/Users/tom/.m2/repository/net/java/dev/jets3t/jets3t/0.6.1/jets3t-0.6.1.jar:/Users/tom/.m2/repository/rome/rome/0.9/rome-0.9.jar:/Users/tom/.m2/repository/commons-logging/commons-logging/1.1.1/commons-logging-1.1.1.jar:/Users/tom/.m2/repository/com/sun/jersey/jersey-test-framework/jersey-test-framework-grizzly2/1.8/jersey-test-framework-grizzly2-1.8.jar:/Users/tom/.m2/repository/com/google/code/findbugs/jsr305/2.0.1/jsr305-2.0.1.jar:/Users/tom/.m2/repository/xmlenc/xmlenc/0.52/xmlenc-0.52.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-yarn-server-web-proxy/2.0.0-cdh4.3.0/hadoop-yarn-server-web-proxy-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/antlr/antlr/3.4/antlr-3.4.jar:/Users/tom/.m2/repository/org/restlet/jee/org.restlet/2.1.1/org.restlet-2.1.1.jar:/Users/tom/.m2/repository/org/glassfish/javax.servlet/3.0/javax.servlet-3.0.jar:/Users/tom/.m2/repository/org/mortbay/jetty/jetty-util/6.1.26.cloudera.2/jetty-util-6.1.26.cloudera.2.jar:/Users/tom/.m2/repository/org/slf4j/slf4j-api/1.6.1/slf4j-api-1.6.1.jar:/Users/tom/.m2/repository/org/codehaus/jackson/jackson-xc/1.8.8/jackson-xc-1.8.8.jar:/Users/tom/.m2/repository/org/twdata/maven/mojo-executor/1.5/mojo-executor-1.5.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-hdfs/2.0.0-cdh4.3.0/hadoop-hdfs-2.0.0-cdh4.3.0-tests.jar:/Users/tom/.m2/repository/org/apache/flume/flume-ng-core/1.3.0-cdh4.3.0/flume-ng-core-1.3.0-cdh4.3.0.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-common/2.0.0-cdh4.3.0/hadoop-common-2.0.0-cdh4.3.0-tests.jar:/Users/tom/.m2/repository/org/apache/derby/derby/10.6.1.0/derby-10.6.1.0.jar:/Users/tom/.m2/repository/org/apache/hive/hive-metastore/0.10.0-cdh4.3.0/hive-metastore-0.10.0-cdh4.3.0.jar:/Users/tom/.m2/repository/com/yammer/metrics/metrics-core/2.1.2/metrics-core-2.1.2.jar:/Users/tom/.m2/repository/org/glassfish/grizzly/grizzly-framework/2.1.1/grizzly-framework-2.1.1.jar:/Users/tom/.m2/repository/org/mockito/mockito-all/1.8.5/mockito-all-1.8.5.jar:/Users/tom/.m2/repository/commons-beanutils/commons-beanutils/1.7.0/commons-beanutils-1.7.0.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-yarn-api/2.0.0-cdh4.3.0/hadoop-yarn-api-2.0.0-cdh4.3.0.jar:/Users/tom/.m2/repository/com/google/code/findbugs/annotations/2.0.1/annotations-2.0.1.jar:/Users/tom/.m2/repository/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar:/Users/tom/.m2/repository/org/apache/maven/maven-artifact/2.0.6/maven-artifact-2.0.6.jar:/Users/tom/.m2/repository/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/Users/tom/.m2/repository/com/googlecode/json-simple/json-simple/1.1/json-simple-1.1.jar:/Users/tom/.m2/repository/commons-digester/commons-digester/1.8/commons-digester-1.8.jar:/Users/tom/.m2/repository/edu/ucar/netcdf/4.2-min/netcdf-4.2-min.jar:/Users/tom/.m2/repository/com/cloudera/cdk/cdk-morphlines-solr-cell/0.7.0-SNAPSHOT/cdk-morphlines-solr-cell-0.7.0-SNAPSHOT.jar:/Users/tom/.m2/repository/org/apache/lucene/lucene-queries/4.4.0/lucene-queries-4.4.0.jar:/Users/tom/.m2/repository/org/mortbay/jetty/jsp-api-2.1/6.1.14/jsp-api-2.1-6.1.14.jar:/Users/tom/.m2/repository/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/Users/tom/.m2/repository/org/glassfish/gmbal/gmbal-api-only/3.0.0-b023/gmbal-api-only-3.0.0-b023.jar:/Users/tom/.m2/repository/org/apache/hadoop/hadoop-auth/2.0.5-alpha/hadoop-auth-2.0.5-alpha.jar:/Users/tom/.m2/repository/org/javassist/javassist/3.16.1-GA/javassist-3.16.1-GA.jar:/Users/tom/.m2/repository/org/sonatype/plexus/plexus-cipher/1.4/plexus-cipher-1.4.jar:/Users/tom/.m2/repository/org/apache/oozie/oozie-client/3.3.2-cdh4.3.0/oozie-client-3.3.2-cdh4.3.0.jar:/Users/tom/.m2/repository/org/sonatype/aether/aether-api/1.7/aether-api-1.7.jar:/Users/tom/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:/Users/tom/.m2/repository/com/codahale/metrics/metrics-core/3.0.1/metrics-core-3.0.1.jar:/Users/tom/.m2/repository/org/apache/crunch/crunch-core/0.7.0-hadoop2/crunch-core-0.7.0-hadoop2.jar:/Users/tom/.m2/repository/com/fasterxml/jackson/core/jackson-core/2.2.1/jackson-core-2.2.1.jar:/Users/tom/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.2.1/jackson-databind-2.2.1.jar:/Users/tom/.m2/repository/org/apache/commons/commons-jexl/2.1.1/commons-jexl-2.1.1.jar:/Users/tom/.m2/repository/asm/asm/3.2/asm-3.2.jar -encoding UTF-8 -protected -sourcepath /Users/tom/workspace/cdk/cdk-data/cdk-data-core/src/main/java:/Users/tom/workspace/cdk/cdk-data/cdk-data-core/target/generated-sources/avro:/Users/tom/workspace/cdk/cdk-data/cdk-data-core/src/main/javadoc:/Users/tom/workspace/cdk/cdk-data/cdk-data-crunch/src/main/java:/Users/tom/workspace/cdk/cdk-data/cdk-data-flume/src/main/java:/Users/tom/workspace/cdk/cdk-data/cdk-data-hcatalog/src/main/java:/Users/tom/workspace/cdk/cdk-data/cdk-data-hbase/src/main/java:/Users/tom/workspace/cdk/cdk-data/cdk-data-hbase/target/generated-sources/src/main/java:/Users/tom/workspace/cdk/cdk-data/cdk-data-hbase/target/generated-sources/src/test/java:/Users/tom/workspace/cdk/cdk-flume-avro-event-serializer/src/main/java:/Users/tom/workspace/cdk/cdk-maven-plugin/src/main/java:/Users/tom/workspace/cdk/cdk-tools/src/main/java:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-core/src/main/java:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-avro/src/main/java:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-json/src/main/java:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-saxon/src/main/java:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-tika-core/src/main/java:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-tika-decompress/src/main/java:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-twitter/src/main/java:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-hadoop-sequencefile/src/main/java:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-solr-core/src/main/java:/Users/tom/workspace/cdk/cdk-morphlines/cdk-morphlines-solr-cell/src/main/java -apiname CDK 0.7.0-SNAPSHOT -->
<package name="com.cloudera.cdk.data">
  <!-- start interface com.cloudera.cdk.data.Dataset -->
  <interface name="Dataset"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of a {@code Dataset}. No guarantees about the format of this
 name are made.]]>
      </doc>
    </method>
    <method name="getDescriptor" return="com.cloudera.cdk.data.DatasetDescriptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link DatasetDescriptor} associated with this dataset.]]>
      </doc>
    </method>
    <method name="getPartition" return="com.cloudera.cdk.data.Dataset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.cloudera.cdk.data.PartitionKey"/>
      <param name="autoCreate" type="boolean"/>
      <doc>
      <![CDATA[Get a partition for a {@link PartitionKey}, possibly creating the partition
 if it doesn't already exist. A {@link PartitionKey} may be obtained using
 {@link PartitionStrategy#partitionKey(Object...)} or
 {@link PartitionStrategy#partitionKeyForEntity(Object)}.

 @param key        The key used to look up the partition.
 @param autoCreate If true, automatically create the partition if doesn't exist,
 @throws DatasetException]]>
      </doc>
    </method>
    <method name="dropPartition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.cloudera.cdk.data.PartitionKey"/>
      <doc>
      <![CDATA[Drop a partition for a {@link PartitionKey}. Dropping a partition that
 doesn't exist results in a {@link DatasetException} being thrown.

 @param key The key used to look up the partition.
 @throws DatasetException
 @since 0.2.0]]>
      </doc>
    </method>
    <method name="getWriter" return="com.cloudera.cdk.data.DatasetWriter&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Get an appropriate {@link DatasetWriter} implementation based on the
 underlying {@code Dataset} implementation.
 </p>
 <p>
 Implementations are free to return different types of writers depending on
 the disposition of the data. For example, a partitioned dataset may use a
 different writer than that of a non-partitioned dataset. Clients should not
 make any assumptions about the returned implementations. {@link Dataset}
 implementations are free to change them at any time.
 </p>

 @throws DatasetException]]>
      </doc>
    </method>
    <method name="getReader" return="com.cloudera.cdk.data.DatasetReader&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Get an appropriate {@link DatasetReader} implementation based on the
 underlying {@code Dataset} implementation.
 </p>
 <p>
 Implementations are free to return different types of readers depending on
 the disposition of the data. For example, a partitioned dataset may use a
 different reader than that of a non-partitioned dataset. Clients should not
 make any assumptions about the returned implementations. {@code Dataset}
 implementations are free to change them at any time.
 </p>

 @throws DatasetException]]>
      </doc>
    </method>
    <method name="getPartitions" return="java.lang.Iterable&lt;com.cloudera.cdk.data.Dataset&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Return partitions, if this dataset is partitioned.
 </p>
 <p>
 Note that, depending on the implementation, the returned iterable may hold
 system resources until exhausted and/or finalized.
 </p>

 @return an iterable over all partitions of this dataset
 @throws DatasetException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A logical representation of a set of data entities.
 </p>
 <p>
 Logically, all datasets have two generic properties: a name, and a descriptor
 that holds information such as the dataset's schema and its partitioning
 information. Concrete implementations of {@code Dataset} may support
 additional properties, mandatory or otherwise, as needed. {@code Dataset}s
 are not normally instantiated directly, but managed by a repository (also
 implementation-specific).
 </p>
 <p>
 Implementations of {@link Dataset} are immutable.
 </p>

 @see DatasetRepository
 @see DatasetWriter
 @see DatasetReader
 @see PartitionStrategy
 @see DatasetDescriptor
 @see Schema]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.Dataset -->
  <!-- start class com.cloudera.cdk.data.DatasetDescriptor -->
  <class name="DatasetDescriptor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetDescriptor" type="org.apache.avro.Schema, com.cloudera.cdk.data.PartitionStrategy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance of this class with the supplied {@link Schema},
 and optional {@link PartitionStrategy}. The default {@link Format},
 {@link Formats#AVRO}, will be used.]]>
      </doc>
    </constructor>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the associated {@link Schema}. Depending on the underlying storage
 system, this schema may be simple (i.e. records made up of only scalar
 types) or complex (i.e. containing other records, lists, and so on).
 Validation of the supported schemas is performed by the managing
 repository, not the dataset or descriptor itself.

 @return the schema]]>
      </doc>
    </method>
    <method name="getSchemaUrl" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a URL from which the {@link Schema} may be retrieved. Optional. This method
 may return <code>null</code> if the schema is not stored at a persistent URL,
 e.g. if it was constructed from a literal string.

 @return a URL from which the schema may be retrieved
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="getFormat" return="com.cloudera.cdk.data.Format"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the associated {@link Format} that the data is stored in.

 @return the format
 @since 0.2.0]]>
      </doc>
    </method>
    <method name="getPartitionStrategy" return="com.cloudera.cdk.data.PartitionStrategy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link PartitionStrategy}, if this dataset is partitioned. Calling
 this method on a non-partitioned dataset is an error. Instead, use the
 {@link #isPartitioned()} method prior to invocation.]]>
      </doc>
    </method>
    <method name="isPartitioned" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if an associated dataset is partitioned (that is, has an
 associated {@link PartitionStrategy}, false otherwise.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 The structural definition of a {@link Dataset}.
 </p>
 <p>
 Each {@code Dataset} has an associated {@link Schema} and optional
 {@link PartitionStrategy} defined at the time of creation. Instances of this
 class are used to hold this information. Users are strongly encouraged to use
 the inner {@link Builder} to create new instances.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.DatasetDescriptor -->
  <!-- start class com.cloudera.cdk.data.DatasetDescriptor.Builder -->
  <class name="DatasetDescriptor.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Supplier&lt;com.cloudera.cdk.data.DatasetDescriptor&gt;"/>
    <constructor name="DatasetDescriptor.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="schema" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
      <doc>
      <![CDATA[Configure the dataset's schema. A schema is required, and may be set
 using one of the <code>schema</code> or
 <code>schemaFromAvroDataFile</code> methods.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schema" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema from a {@link File}. A schema is required,
 and may be set using one of the <code>schema</code> or
 <code>schemaFromAvroDataFile</code> methods.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schema" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema from an {@link InputStream}. It is the
 caller's responsibility to close the {@link InputStream}. A schema is
 required, and may be set using one of the <code>schema</code> or
 <code>schemaFromAvroDataFile</code> methods.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schema" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema from a {@link URI}. A schema is required,
 and may be set using one of the <code>schema</code> or
 <code>schemaFromAvroDataFile</code> methods.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schema" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure the dataset's schema from a {@link String}. A schema is
 required, and may be set using one of the <code>schema</code> or
 <code>schemaFromAvroDataFile</code> methods.

 @return An instance of the builder for method chaining.
 @since 0.2.0]]>
      </doc>
    </method>
    <method name="schema" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Configure the dataset's schema via a Java class type. A schema is required,
 and may be set using one of the <code>schema</code> or
 <code>schemaFromAvroDataFile</code> methods.

 @return An instance of the builder for method chaining.
 @since 0.2.0]]>
      </doc>
    </method>
    <method name="schemaFromAvroDataFile" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema by using the schema from an existing Avro
 data file. A schema is required, and may be set using one of the
 <code>schema</code> or <code>schemaFromAvroDataFile</code> methods.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schemaFromAvroDataFile" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema by using the schema from an existing Avro
 data file. It is the caller's responsibility to close the
 {@link InputStream}. A schema is required, and may be set using one of
 the <code>schema</code> or <code>schemaFromAvroDataFile</code> methods.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schemaFromAvroDataFile" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema by using the schema from an existing Avro
 data file. A schema is required, and may be set using one of the
 <code>schema</code> or <code>schemaFromAvroDataFile</code> methods.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="format" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="com.cloudera.cdk.data.Format"/>
      <doc>
      <![CDATA[Configure the dataset's format. Optional. If not specified {@link Formats#AVRO}
 is used by default.

 @return An instance of the builder for method chaining.
 @since 0.2.0]]>
      </doc>
    </method>
    <method name="partitionStrategy" return="com.cloudera.cdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="partitionStrategy" type="com.cloudera.cdk.data.PartitionStrategy"/>
      <doc>
      <![CDATA[Configure the dataset's partitioning strategy. Optional.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="get" return="com.cloudera.cdk.data.DatasetDescriptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an instance of the configured dataset descriptor. Subsequent calls
 will produce new instances that are similarly configure.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A fluent builder to aid in the construction of {@link DatasetDescriptor}s.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.DatasetDescriptor.Builder -->
  <!-- start class com.cloudera.cdk.data.DatasetException -->
  <class name="DatasetException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[<p>
 Exception thrown for dataset-related failures.
 </p>
 <p>
 Implementations of the {@link Dataset} interface throw this exception if
 any of their operations fail. This is a runtime (unchecked) exception.
 </p>

 @see Dataset
 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.DatasetException -->
  <!-- start interface com.cloudera.cdk.data.DatasetReader -->
  <interface name="DatasetReader"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;E&gt;"/>
    <implements name="java.lang.Iterable&lt;E&gt;"/>
    <implements name="java.io.Closeable"/>
    <method name="open"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Open the reader, allocating any necessary resources required to produce
 entities.
 </p>
 <p>
 This method <strong>must</strong> be invoked prior to any calls of
 {@link #hasNext()} or {@link #read()}.
 </p>

 @throws UnknownFormatException
 @throws DatasetReaderException]]>
      </doc>
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tests the reader to see if additional entities can be read.

 @return true if additional entities exist, false otherwise.
 @throws DatasetReaderException]]>
      </doc>
    </method>
    <method name="read" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="will be removed in 0.8.x">
      <doc>
      <![CDATA[<p>
 Deprecated synonym for {@link #next()}.
 </p>
 @deprecated will be removed in 0.8.x]]>
      </doc>
    </method>
    <method name="next" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Fetch the next entity from the reader.
 </p>
 <p>
 Calling this method when no additional data exists is illegal; users should
 use {@link #hasNext()} to test if a call to {@code read()} will succeed.
 Implementations of this method may block.
 </p>

 @return An entity of type {@code E}.
 @throws DatasetReaderException
 @throws NoSuchElementException]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Remove the last entity from the reader (OPTIONAL).
 </p>
 <p>
 This has the same semantics as {@link Iterator#remove()}, but is unlikely
 to be implemented.
 </p>]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Close the reader and release any system resources.
 </p>
 <p>
 No further operations of this interface (other than additional calls of
 this method) may be performed, however implementations may choose to permit
 other method calls. See implementation documentation for details.
 </p>

 @throws DatasetReaderException]]>
      </doc>
    </method>
    <method name="isOpen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 A stream-oriented dataset reader.
 </p>
 <p>
 Subsystem-specific implementations of this interface are used to read data
 from a {@link Dataset}. Readers are use-once objects that produce entities of
 type {@code E}. Normally, users are not expected to instantiate
 implementations directly. Instead, use the containing dataset's
 {@link Dataset#getReader()} method to get an appropriate implementation.
 Normally, users receive an instance of this interface from a dataset, call
 {@link #open()} to prepare for IO operations, invoke {@link #hasNext()} and
 {@link #read()} as necessary, and {@link #close()} when they are done or no
 more data exists.
 </p>
 <p>
 Implementations may hold system resources until the {@link #close()} method
 is called, so users <strong>must</strong> follow the normal try / finally
 pattern to ensure these resources are properly freed when the reader is
 exhausted or no longer useful. Do not rely on implementations automatically
 invoking the {@code close()} method upon object finalization (although
 implementations are free to do so, if they choose). All implementations must
 silently ignore multiple invocations of {@code close()} as well as a close of
 an unopened reader.
 </p>
 <p>
 If any method throws an exception, the reader is no longer valid, and the
 only method that may be subsequently called is {@code close()}.
 </p>
 <p>
 Implementations of {@link DatasetReader} are typically not thread-safe; that is,
 the behavior when accessing a single instance from multiple threads is undefined.
 </p>

 @param <E> The type of entity produced by this reader.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.DatasetReader -->
  <!-- start class com.cloudera.cdk.data.DatasetReaderException -->
  <class name="DatasetReaderException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetReaderException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetReaderException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetReaderException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetReaderException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[<p>
 Exception thrown for dataset reader-related failures.
 </p>
 <p>
 Implementations of the {@link DatasetReader} interface throw this exception
 if any of their operations fail. This is a runtime (unchecked) exception.
 </p>

 @see DatasetReader
 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.DatasetReaderException -->
  <!-- start interface com.cloudera.cdk.data.DatasetRepository -->
  <interface name="DatasetRepository"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="com.cloudera.cdk.data.Dataset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the latest version of a named {@link Dataset}. If no dataset with the
 provided {@code name} exists, a {@link DatasetRepositoryException} is thrown.

 @param name The name of the dataset.
 @throws DatasetRepositoryException]]>
      </doc>
    </method>
    <method name="create" return="com.cloudera.cdk.data.Dataset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="descriptor" type="com.cloudera.cdk.data.DatasetDescriptor"/>
      <doc>
      <![CDATA[Create a {@link Dataset} with the supplied {@code descriptor}. Depending on
 the underlying dataset storage, some schemas types or configurations may
 not be supported. If an illegal schema is supplied, an exception will be
 thrown by the implementing class. It is illegal to create a more than one
 dataset with a given name. If a duplicate name is provided, an exception is
 thrown.

 @param name       The fully qualified dataset name
 @param descriptor A descriptor that describes the schema and other properties of the
                   dataset
 @return The newly created dataset
 @throws DatasetRepositoryException]]>
      </doc>
    </method>
    <method name="update" return="com.cloudera.cdk.data.Dataset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="descriptor" type="com.cloudera.cdk.data.DatasetDescriptor"/>
      <doc>
      <![CDATA[Update an existing {@link Dataset} to reflect the supplied {@code descriptor}. The
 common case is updating a dataset schema. Depending on
 the underlying dataset storage, some updates may not be supported,
 such as a change in format or partition strategy.
 Any attempt to make an unsupported or incompatible update will result in an
 exception being thrown and no change being made to the dataset.

 @param name       The fully qualified dataset name
 @param descriptor A descriptor that describes the schema and other properties of the
                   dataset
 @return The newly created dataset
 @throws DatasetRepositoryException
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="drop" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Drop the named {@link Dataset}. If no dataset with the
 provided {@code name} exists, a {@link DatasetReaderException} is thrown.

 @param name The name of the dataset.
 @return <code>true</code> if the dataset was successfully dropped, false otherwise
 @throws DatasetReaderException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A logical repository (storage system) of {@link Dataset}s.
 </p>
 <p>
 Implementations of {@code DatasetRepository} are storage systems that contain
 zero or more {@link Dataset}s. A repository acts as a factory, as well as a
 registry, of datasets. Users can {@link #create(String, DatasetDescriptor)} a
 new {@link Dataset} with a name and schema, or retrieve a handle to an
 existing dataset, by name, by way of the {@link #get(String)} method. While
 not expressly forbidden, most repositories are expected to support only a
 single concrete {@link Dataset} implementation.
 </p>
 <p>
 No guarantees are made as to the durability, reliability, or availability of
 the underlying storage. That is, a {@code DatasetRepository} could be on
 disk, in memory, or some combination. See the implementation class for
 details about the guarantees it provides.
 </p>
 <p>
 Implementations of {@link DatasetRepository} are immutable.
 </p>

 @see Dataset
 @see DatasetDescriptor]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.DatasetRepository -->
  <!-- start class com.cloudera.cdk.data.DatasetRepositoryException -->
  <class name="DatasetRepositoryException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetRepositoryException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetRepositoryException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetRepositoryException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetRepositoryException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[<p>
 Exception thrown for dataset repository-related failures.
 </p>
 <p>
 Implementations of the {@link DatasetRepository} interface throw this
 exception if any of their operations fail. This is a runtime (unchecked)
 exception.
 </p>

 @see DatasetRepository
 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.DatasetRepositoryException -->
  <!-- start interface com.cloudera.cdk.data.DatasetWriter -->
  <interface name="DatasetWriter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <implements name="java.io.Closeable"/>
    <method name="open"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Open the writer, allocating any necessary resources required to store
 entities.
 </p>
 <p>
 This method <strong>must</strong> be invoked prior to any calls of
 {@link #write(Object)} or {@link #flush()}.
 </p>

 @throws DatasetWriterException]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="E"/>
      <doc>
      <![CDATA[<p>
 Writer an entity of type {@code E} to the associated dataset.
 </p>
 <p>
 Implementations may buffer entities internally (see the {@link #flush()}
 method). All instances of {@code entity} must conform to the dataset's
 schema and partition. If they don't, implementations should throw an exception,
 although this is not required.
 </p>

 @param entity The entity to write
 @throws DatasetWriterException]]>
      </doc>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Force or commit any outstanding data to storage.
 </p>
 <p>
 Implementations of this interface must declare their durability guarantees.
 </p>

 @throws DatasetWriterException]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Close the writer and release any system resources.
 </p>
 <p>
 No further operations of this interface (other than additional calls to
 this method) may be performed, however implementations may choose to permit
 other method calls. See implementation documentation for details.
 </p>

 @throws DatasetWriterException]]>
      </doc>
    </method>
    <method name="isOpen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 A stream-oriented dataset writer.
 </p>
 <p>
 Subsystem-specific implementations of this interface are used to write data
 to a {@link Dataset}. Writers are use-once objects that serialize entities of
 type {@code E} and write them to the underlying system. Normally, users are
 not expected to instantiate implementations directly. Instead, use the
 containing dataset's {@link Dataset#getWriter()} method to get an appropriate
 implementation. Users should receive an instance of this interface from a
 dataset, call {@link #open()} to prepare for IO operations, invoke
 {@link #write(Object)} and {@link #flush()} as necessary, and
 {@link #close()} when they are done, or no more data exists.
 </p>
 <p>
 Implementations may hold system resources until the {@link #close()} method
 is called, so users <strong>must</strong> follow the normal try / finally
 pattern to ensure these resources are properly freed when the writer is no
 longer needed. Do not rely on implementations automatically invoking the
 {@code close()} method upon object finalization (implementations must not do
 so). All implementations must silently ignore multiple invocations of
 {@code close()} as well as a close of an unopened writer.
 </p>
 <p>
 If any method throws an exception, the writer is no longer valid, and the
 only method that may be subsequently called is {@code close()}.
 </p>
 <p>
 Implementations of {@link DatasetWriter} are typically not thread-safe; that is,
 the behavior when accessing a single instance from multiple threads is undefined.
 </p>

 @param <E> The type of entity accepted by this writer.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.DatasetWriter -->
  <!-- start class com.cloudera.cdk.data.DatasetWriterException -->
  <class name="DatasetWriterException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetWriterException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetWriterException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetWriterException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetWriterException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[<p>
 Exception thrown for dataset writer-related failures.
 </p>
 <p>
 Implementations of the {@link DatasetWriter} interface throw this exception
 if any of their operations fail. This is a runtime (unchecked) exception.
 </p>

 @see DatasetWriter
 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.DatasetWriterException -->
  <!-- start class com.cloudera.cdk.data.FieldPartitioner -->
  <class name="FieldPartitioner" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Function&lt;java.lang.Object, java.lang.Object&gt;"/>
    <constructor name="FieldPartitioner" type="java.lang.String, int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FieldPartitioner" type="java.lang.String, java.lang.String, int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the name of the partition field. Note that the partition field is derived
 from {@link #getSourceName()} and does not appear in the dataset entity.]]>
      </doc>
    </method>
    <method name="getSourceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the name of the field from which the partition field is derived.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="getCardinality" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the number of buckets in the partition.]]>
      </doc>
    </method>
    <method name="apply" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[<p>
 Apply the partition function to the given {@code value}.
 </p>
 <p>
 The type of value must be compatible with the field partitioner
 implementation. Normally, this is validated at the time of initial
 configuration rather than at runtime.
 </p>]]>
      </doc>
    </method>
    <method name="valueFromString" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
      <doc>
      <![CDATA[<p>
 Retrieve the value for the field from the string representation.
 </p>
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="valueToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[<p>
 Retrieve the value for the field formatted as a {@link String}. By default,
 this is the object's {@link Object#toString()} representation,
 but some {@link FieldPartitioner}s may choose to provide a different representation.
 </p>
 @since 0.4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 Partitions values for a named field.
 </p>
 <p>
 Used by a {@link PartitionStrategy} to calculate which partition an entity
 belongs in, based on the value of a given field, called the source field. A field
 partitioner can, in some cases, provide meaningful cardinality hints to query
 systems. A good example of this is a hash partitioner which always knows the number of
 buckets produced by the function.
 </p>
 <p>
 Implementations of {@link FieldPartitioner} are immutable.
 </p>
 
 @see PartitionStrategy]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.FieldPartitioner -->
  <!-- start class com.cloudera.cdk.data.Format -->
  <class name="Format" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the format's name.
 @return the name]]>
      </doc>
    </method>
    <method name="getExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the extension for use in filenames. A dot is not included as a part of the
 extension.
 @return the extension]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 The data format used for encoding the data in a {@link Dataset} when stored in a
 {@link DatasetRepository}.
 </p>
 <p>
 There are a small number of formats provided, the default is {@link Formats#AVRO},
 which will be used when no format is explicitly configured.
 </p>

 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.Format -->
  <!-- start class com.cloudera.cdk.data.Formats -->
  <class name="Formats" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="AVRO" type="com.cloudera.cdk.data.Format"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[AVRO: the
 <a href="http://avro.apache.org/docs/current/spec.html#Object+Container+Files">Avro
 row-oriented format</a>]]>
      </doc>
    </field>
    <field name="PARQUET" type="com.cloudera.cdk.data.Format"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[PARQUET: the <a href="http://parquet.io/">Parquet columnar format</a>]]>
      </doc>
    </field>
    <doc>
    <![CDATA[<p>
 Contains constant definitions for the standard {@link Format} instances supported
 by the library. {@link #AVRO} is the default format.
 </p>

 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.Formats -->
  <!-- start interface com.cloudera.cdk.data.MetadataProvider -->
  <interface name="MetadataProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="load" return="com.cloudera.cdk.data.DatasetDescriptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Load the dataset descriptor for the dataset {@code name}.

 @param name The fully qualified name of an existing dataset.
 @return A dataset descriptor.
 @throws MetadataProviderException If the dataset doesn't exist or the descriptor can not be loaded.]]>
      </doc>
    </method>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="descriptor" type="com.cloudera.cdk.data.DatasetDescriptor"/>
      <doc>
      <![CDATA[Save the dataset descriptor for the dataset {@code name}.

 @param name       The fully qualified name of a dataset.
 @param descriptor A dataset descriptor.
 @throws MetadataProviderException If the dataset descriptor can not be saved.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Delete all metadata associated with the dataset named {@code name}.

 @param name The fully qualified name of a dataset.
 @return True if the dataset is successfully deleted, false if the dataset
         doesn't exist.
 @throws MetadataProviderException If the dataset metadata exists but can not be deleted.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 Defines a service provider interface for metadata system plugins.
 </p>
 <p>
 Implementations of {@link DatasetRepository} are written against this
 interface and, by extension, can store dataset metadata information contained
 in the {@link DatasetDescriptor} in a system of the user's choosing.
 </p>
 <p>
 Implementations of {@link MetadataProvider} are typically not thread-safe; that is,
 the behavior when accessing a single instance from multiple threads is undefined.
 </p>]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.MetadataProvider -->
  <!-- start class com.cloudera.cdk.data.MetadataProviderException -->
  <class name="MetadataProviderException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetadataProviderException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MetadataProviderException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MetadataProviderException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MetadataProviderException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[<p>
 Exception thrown for metadata provider-related failures.
 </p>
 <p>
 Implementations of the {@link MetadataProvider} interface throw this
 exception if any of their operations fail. This is a runtime (unchecked)
 exception.
 </p>

 @see MetadataProvider
 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.MetadataProviderException -->
  <!-- start class com.cloudera.cdk.data.PartitionKey -->
  <class name="PartitionKey" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getValues" return="java.util.List&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Return the value at the specified index in the key.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of values in the key.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 A key for retrieving partitions from a {@link Dataset}.
 </p>
 <p>
 A {@code PartitionKey} is a ordered sequence of values corresponding to the
 {@link FieldPartitioner}s in a {@link PartitionStrategy}. A
 {@link PartitionKey} may be obtained using
 {@link PartitionStrategy#partitionKey(Object...)} or
 {@link PartitionStrategy#partitionKeyForEntity(Object)}.
 </p>
 <p>
 Implementations of {@link PartitionKey} are typically not thread-safe; that is,
 the behavior when accessing a single instance from multiple threads is undefined.
 </p>
 
 @see PartitionStrategy
 @see FieldPartitioner
 @see Dataset]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.PartitionKey -->
  <!-- start class com.cloudera.cdk.data.PartitionStrategy -->
  <class name="PartitionStrategy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PartitionStrategy" type="com.cloudera.cdk.data.FieldPartitioner[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a partition strategy with a variadic array of field partitioners.]]>
      </doc>
    </constructor>
    <constructor name="PartitionStrategy" type="java.util.List&lt;com.cloudera.cdk.data.FieldPartitioner&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a partition strategy with a list of field partitioners.]]>
      </doc>
    </constructor>
    <method name="getFieldPartitioners" return="java.util.List&lt;com.cloudera.cdk.data.FieldPartitioner&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Get the list of field partitioners used for partitioning.
 </p>
 <p>
 {@link FieldPartitioner}s are returned in the same order they are used
 during partition selection.
 </p>]]>
      </doc>
    </method>
    <method name="getCardinality" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Return the cardinality produced by the contained field partitioners.
 </p>
 <p>
 This can be used to aid in calculating resource usage used during certain
 operations. For example, when writing data to a partitioned dataset, this
 method can be used to estimate (or discover exactly, depending on the
 partition functions) how many leaf partitions exist.
 </p>
 <p>
 <strong>Warning:</strong> This method is allowed to lie and should be
 treated only as a hint. Some partition functions are fixed (e.g. hash
 modulo number of buckets), while others are open-ended (e.g. discrete
 value) and depend on the input data.
 </p>
 
 @return The estimated (or possibly concrete) number of leaf partitions.]]>
      </doc>
    </method>
    <method name="partitionKey" return="com.cloudera.cdk.data.PartitionKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[<p>
 Construct a partition key with a variadic array of values corresponding to
 the field partitioners in this partition strategy.
 </p>
 <p>
 It is permitted to have fewer values than field partitioners, in which case
 all subpartititions in the unspecified parts of the key are matched by the
 key.
 </p>
 <p>
 Null values are not permitted.
 </p>]]>
      </doc>
    </method>
    <method name="partitionKeyForEntity" return="com.cloudera.cdk.data.PartitionKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
      <doc>
      <![CDATA[<p>
 Construct a partition key for the given entity.
 </p>
 <p>
 This is a convenient way to find the partition that a given entity would be
 written to, or to find a partition using objects from the entity domain.
 </p>]]>
      </doc>
    </method>
    <method name="partitionKeyForEntity" return="com.cloudera.cdk.data.PartitionKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
      <param name="reuseKey" type="com.cloudera.cdk.data.PartitionKey"/>
      <doc>
      <![CDATA[<p>
 Construct a partition key for the given entity, reusing the supplied key if not
 null.
 </p>
 <p>
 This is a convenient way to find the partition that a given entity would be
 written to, or to find a partition using objects from the entity domain.
 </p>]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 The strategy used to determine how a dataset is partitioned.
 </p>
 <p>
 A {@code PartitionStrategy} is configured with one or more
 {@link FieldPartitioner}s upon creation. When a {@link Dataset} is configured
 with a partition strategy, we say that data is partitioned. Any entities
 written to a partitioned dataset are evaluated with its
 {@code PartitionStrategy} which, in turn, produces a {@link PartitionKey}
 that is used by the dataset implementation to select the proper partition.
 </p>
 
 @see FieldPartitioner
 @see PartitionKey
 @see DatasetDescriptor
 @see Dataset]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.PartitionStrategy -->
  <!-- start class com.cloudera.cdk.data.PartitionStrategy.Builder -->
  <class name="PartitionStrategy.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Supplier&lt;com.cloudera.cdk.data.PartitionStrategy&gt;"/>
    <constructor name="PartitionStrategy.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hash" return="com.cloudera.cdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="buckets" type="int"/>
      <doc>
      <![CDATA[Configure a hash partitioner with the specified number of {@code buckets}
 .
 
 @param name
          The entity field name from which to get values to be
          partitioned.
 @param buckets
          The number of buckets into which data is to be partitioned.
 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="hash" return="com.cloudera.cdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="buckets" type="int"/>
      <doc>
      <![CDATA[Configure a hash partitioner with the specified number of {@code buckets}
 .

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @param buckets
          The number of buckets into which data is to be partitioned.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="identity" return="com.cloudera.cdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="buckets" type="int"/>
      <doc>
      <![CDATA[Configure an identity partitioner with a cardinality hint of
 {@code buckets} size.
 
 @param name
          The entity field name from which to get values to be
          partitioned.
 @param buckets
          A hint as to the number of partitions that will be created (i.e.
          the number of discrete values for the field {@code name} in the
          data).
 @return An instance of the builder for method chaining.
 @see IdentityFieldPartitioner]]>
      </doc>
    </method>
    <method name="range" return="com.cloudera.cdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="upperBounds" type="int[]"/>
      <doc>
      <![CDATA[Configure a range partitioner with a set of {@code upperBounds}.
 
 @param name
          The entity field name from which to get values to be
          partitioned.
 @param upperBounds
          A variadic list of upper bounds of each partition.
 @return An instance of the builder for method chaining.
 @see IntRangeFieldPartitioner]]>
      </doc>
    </method>
    <method name="range" return="com.cloudera.cdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="upperBounds" type="java.lang.Comparable[]"/>
      <doc>
      <![CDATA[Configure a range partitioner with a set of {@code upperBounds}.
 
 @param name
          The entity field name from which to get values to be
          partitioned.
 @param upperBounds
          A variadic list of upper bounds of each partition.
 @return An instance of the builder for method chaining.
 @see com.cloudera.cdk.data.partition.RangeFieldPartitioner]]>
      </doc>
    </method>
    <method name="year" return="com.cloudera.cdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the year from a timestamp field.
 The UTC timezone is assumed.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="month" return="com.cloudera.cdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the month from a timestamp field.
 The UTC timezone is assumed.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="day" return="com.cloudera.cdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the day from a timestamp field.
 The UTC timezone is assumed.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="hour" return="com.cloudera.cdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the hour from a timestamp field.
 The UTC timezone is assumed.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="minute" return="com.cloudera.cdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the minute from a timestamp field.
 The UTC timezone is assumed.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="get" return="com.cloudera.cdk.data.PartitionStrategy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Get the configured {@link PartitionStrategy} instance.
 </p>
 <p>
 This builder should be considered single use and discarded after a call
 to this method.
 </p>
 
 @return The configured instance of {@link PartitionStrategy}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A fluent builder to aid in the construction of {@link PartitionStrategy}s.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.PartitionStrategy.Builder -->
  <!-- start class com.cloudera.cdk.data.UnknownFormatException -->
  <class name="UnknownFormatException" extends="com.cloudera.cdk.data.DatasetReaderException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnknownFormatException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnknownFormatException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnknownFormatException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Un-checked Exception thrown when a Dataset is in an unknown format.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.UnknownFormatException -->
</package>
<package name="com.cloudera.cdk.data.crunch">
  <!-- start class com.cloudera.cdk.data.crunch.CrunchDatasets -->
  <class name="CrunchDatasets" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CrunchDatasets"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="asSource" return="org.apache.crunch.io.ReadableSource&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="com.cloudera.cdk.data.Dataset"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[<p>
 Expose the given {@link Dataset} as a Crunch {@link ReadableSource}.
 </p>
 @param dataset the dataset to read from
 @param type    the Java type of the entities in the dataset
 @param <E>     the type of entity produced by the source
 @return the {@link ReadableSource}, or <code>null</code> if the dataset is not
 filesystem-based.]]>
      </doc>
    </method>
    <method name="asTarget" return="org.apache.crunch.Target"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="com.cloudera.cdk.data.Dataset"/>
      <doc>
      <![CDATA[<p>
 Expose the given {@link Dataset} as a Crunch {@link Target}.
 </p>
 @param dataset the dataset to write to
 @return the {@link Target}, or <code>null</code> if the dataset is not
 filesystem-based.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A helper class for exposing a filesystem-based dataset as a Crunch
 {@link ReadableSource} or {@link Target}.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.crunch.CrunchDatasets -->
</package>
<package name="com.cloudera.cdk.data.dao">
  <!-- start class com.cloudera.cdk.data.dao.ConcurrentSchemaModificationException -->
  <class name="ConcurrentSchemaModificationException" extends="com.cloudera.cdk.data.dao.HBaseCommonException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConcurrentSchemaModificationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ConcurrentSchemaModificationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ConcurrentSchemaModificationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[An exception that indicates a managed schema modification collided with
 another client trying to modify that same managed schema.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.ConcurrentSchemaModificationException -->
  <!-- start class com.cloudera.cdk.data.dao.Constants -->
  <class name="Constants" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Constants"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="SYS_COL_FAMILY" type="byte[]"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OBSERVABLE_COL_FAMILY" type="byte[]"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VERSION_CHECK_COL_QUALIFIER" type="byte[]"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[HBase Common Library Constants]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.Constants -->
  <!-- start interface com.cloudera.cdk.data.dao.Dao -->
  <interface name="Dao"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Return the entity stored in HBase at the row specified with Key key. Return
 null if no such entity exists.

 @param key
          The key entity to get
 @return The entity of type T, or null if one is not found]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
      <doc>
      <![CDATA[Put the entity into the HBase table with K key.

 @param key
 @param entity
          The entity to store
 @return True if the put succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="increment" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="fieldName" type="java.lang.String"/>
      <param name="amount" type="long"/>
      <doc>
      <![CDATA[Increment a field named fieldName on the entity by value.
 
 @param key
          The key of the entity to increment
 @param fieldName
          The name of the field on the entity to increment. If the fieldName
          doesn't exist, an exception will be thrown.
 @param amount
          The amount to increment the field by
 @return The new field amount.]]>
      </doc>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Deletes the entity in the HBase table at K key.

 @param key
          The key of the entity to delete.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
      <doc>
      <![CDATA[Deletes the entity in the HBase table at K key. If that entity has a
 checkConflict field, then the delete will only be performed if the entity
 has the expected value in the table.

 @param key
          The key of the entity to delete.
 @param entity
          The entity, whose checkConflict field may be validated before the
          delete is performed.
 @return True if the put succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="getScanner" return="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a scanner to scan the HBase table this DAO reads from. This method
 opens a scanner starting at the beginning of the table, and will scan to
 the end.

 @return An EntityScanner instance that can be used to iterate through
         entities in the table.]]>
      </doc>
    </method>
    <method name="getScanner" return="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startKey" type="com.cloudera.cdk.data.dao.PartialKey&lt;K&gt;"/>
      <param name="stopKey" type="com.cloudera.cdk.data.dao.PartialKey&lt;K&gt;"/>
      <doc>
      <![CDATA[Get a scanner to scan the HBase table this DAO reads from. The scanner is
 opened starting at the first row greater than or equal to startKey. It will
 stop at the first row it sees greater than or equal to stopKey.

 If startKey is null, it will start at the first row in the table. If
 stopKey is null, it will stop at the last row in the table.

 @param startKey
 @param stopKey
 @return An EntityScanner instance that can be used to iterate through
         entities in the table.]]>
      </doc>
    </method>
    <method name="getScanner" return="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startKey" type="K"/>
      <param name="stopKey" type="K"/>
      <doc>
      <![CDATA[Get a scanner to scan the HBase table this DAO reads from. The scanner is
 opened starting at the first row greater than or equal to startKey. It will
 stop at the first row it sees greater than or equal to stopKey.

 If startKey is null, it will start at the first row in the table. If
 stopKey is null, it will stop at the last row in the table.

 @param startKey
 @param stopKey
 @return An EntityScanner instance that can be used to iterate through
         entities in the table.]]>
      </doc>
    </method>
    <method name="getKeySchema" return="com.cloudera.cdk.data.dao.KeySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key schema instance for this DAO.

 @return The HBaseCommonKeySchema instance.]]>
      </doc>
    </method>
    <method name="getEntitySchema" return="com.cloudera.cdk.data.dao.EntitySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity schema instance for this DAO.

 @return The HBaseCommonEntitySchema instance.]]>
      </doc>
    </method>
    <method name="newBatch" return="com.cloudera.cdk.data.dao.EntityBatch&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeBufferSize" type="long"/>
      <doc>
      <![CDATA[Create an EntityBatch with a specified buffer size in bytes

 @param writeBufferSize
          Write buffer size in bytes
 @return EntityBatch]]>
      </doc>
    </method>
    <method name="newBatch" return="com.cloudera.cdk.data.dao.EntityBatch&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an EntityBatch with the default HBase buffer size.

 @return EntityBatch]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for HBase Common DAOs. Supports basic get, put, delete, and scan
 operations over HBase.

 Almost all access and modifier functions take a row key. This key is
 represented by the Key<T> type. The type parameter <T> on the key type is the
 concrete java type that underlies the Key. A key can be constructed from this
 concrete type. All access and modifier methods on the DAO also support the
 ability to pass in this underlying type directly.

 @param <K>
          The underlying key type.
 @param <E>
          The type of entity the DAO should return.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.dao.Dao -->
  <!-- start interface com.cloudera.cdk.data.dao.EntityBatch -->
  <interface name="EntityBatch"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
      <doc>
      <![CDATA[Put the entity into the HBase table with K key. Since this is a part of a
 batch operation, this entity will not be committed to the table until the
 writeBuffer has reached capacity.

 @param key
          The key for this entity
 @param entity
          The entity to store]]>
      </doc>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Flushes the write buffer, committing any and all entities currently in the
 buffer.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This closes and finalizes the batch operation, flushing any remaining
 entities in the buffer.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface com.cloudera.cdk.data.dao.EntityBatch -->
  <!-- start interface com.cloudera.cdk.data.dao.EntityScanner -->
  <interface name="EntityScanner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable&lt;com.cloudera.cdk.data.dao.KeyEntity&lt;K, E&gt;&gt;"/>
    <method name="open"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Opens the scanner over the table, with scan parameters.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closes the entity scanner, and cleans up any underlying resources.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Scanner interface that represents an Iterable that allows us to iterate
 over entities in an HBase table, returning them as KeyEntity instances.
 
 @param <K>
          The underlying key record type
 @param <E>
          The type of the entity to return]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.dao.EntityScanner -->
  <!-- start class com.cloudera.cdk.data.dao.EntitySchema -->
  <class name="EntitySchema" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntitySchema" type="java.util.Collection&lt;java.lang.String&gt;, java.lang.String, java.util.Collection&lt;com.cloudera.cdk.data.dao.EntitySchema.FieldMapping&gt;, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the EntitySchema
 
 @param tables
          The tables this EntitySchema can be persisted to
 @param rawSchema
          The raw schema type that underlies the EntitySchema implementation
 @param fieldMappings
          The list of FieldMappings that specify how each field maps to an
          HBase row
 @param isTransactional
          Specifies whether this entity participates in transactions]]>
      </doc>
    </constructor>
    <method name="isTransactional" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies whether this EntitySchema will participate in transactions.
 
 @return True if it should participate in transactions. Otherwise false.]]>
      </doc>
    </method>
    <method name="getTables" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the tables this EntitySchema can be persisted to.
 
 @return The list of tables.]]>
      </doc>
    </method>
    <method name="getFieldMapping" return="com.cloudera.cdk.data.dao.EntitySchema.FieldMapping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the FieldMapping for the specified fieldName. Returns null if one
 doesn't exist.
 
 @param fieldName
          The field name to get the FieldMapping for
 @return The FieldMapping, or null if one doesn't exist fo rthe fieldName.]]>
      </doc>
    </method>
    <method name="getFieldMappings" return="java.util.Collection&lt;com.cloudera.cdk.data.dao.EntitySchema.FieldMapping&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the FieldMappings for this schema.
 
 @return The collection of FieldMappings]]>
      </doc>
    </method>
    <method name="getRawSchema" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the raw schema that was parsed to create this schema.
 
 @return The raw scheam.]]>
      </doc>
    </method>
    <method name="getRequiredColumns" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the HBase columns required by this schema.
 
 @return The set of columns]]>
      </doc>
    </method>
    <method name="getRequiredColumnFamilies" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the HBase column families required by this schema.
 
 @return The set of column families.]]>
      </doc>
    </method>
    <method name="compatible" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entitySchema" type="com.cloudera.cdk.data.dao.EntitySchema"/>
      <doc>
      <![CDATA[Method meant to determine if two EntitySchemas are compatible with each
 other for schema migration purposes. Classes that inherit EntitySchema
 should override this implementation, since this implemetnation isn't able
 to make that determination.
 
 TODO: Figure out a base set of properties that all entity schema
 implementations should share in their implementation of determining
 compatibility and execute that here.
 
 @param entitySchema
          The other EntitySchema to determine compatible with
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An EntitySchema is the parsed schema that contains the properties of an HBase
 Common entity schema.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.EntitySchema -->
  <!-- start class com.cloudera.cdk.data.dao.EntitySchema.FieldMapping -->
  <class name="EntitySchema.FieldMapping" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntitySchema.FieldMapping" type="java.lang.String, com.cloudera.cdk.data.dao.MappingType, java.lang.String, java.lang.Object, java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFieldName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMappingType" return="com.cloudera.cdk.data.dao.MappingType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMappingValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isIncrementable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFamily" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQualifier" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[A field mapping represents a type that specifies how a schema field maps to
 a column in HBase.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.EntitySchema.FieldMapping -->
  <!-- start class com.cloudera.cdk.data.dao.HBaseClientException -->
  <class name="HBaseClientException" extends="com.cloudera.cdk.data.dao.HBaseCommonException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HBaseClientException" type="java.lang.String, java.io.IOException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getIOException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Wraps IOExceptions exceptions thrown by the HBase Client API.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.HBaseClientException -->
  <!-- start class com.cloudera.cdk.data.dao.HBaseCommonException -->
  <class name="HBaseCommonException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HBaseCommonException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HBaseCommonException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HBaseCommonException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[The base Exception type for HBase Common.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.HBaseCommonException -->
  <!-- start class com.cloudera.cdk.data.dao.IncompatibleSchemaException -->
  <class name="IncompatibleSchemaException" extends="com.cloudera.cdk.data.dao.HBaseCommonException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IncompatibleSchemaException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IncompatibleSchemaException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IncompatibleSchemaException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.IncompatibleSchemaException -->
  <!-- start class com.cloudera.cdk.data.dao.KeyBuildException -->
  <class name="KeyBuildException" extends="com.cloudera.cdk.data.dao.HBaseCommonException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyBuildException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="KeyBuildException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="KeyBuildException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception that is thrown when the construction of a Key fails with an error.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.KeyBuildException -->
  <!-- start class com.cloudera.cdk.data.dao.KeyEntity -->
  <class name="KeyEntity" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyEntity" type="K, E"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntity" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A class that encapsulates a Key and an Entity which is returned from the
 EntityMapper mapToEntity function.

 @param <K>
          The underlying key record type
 @param <E>
          The entity type]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.KeyEntity -->
  <!-- start class com.cloudera.cdk.data.dao.KeySchema -->
  <class name="KeySchema" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeySchema" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param rawSchema
          The raw schema]]>
      </doc>
    </constructor>
    <method name="getRawSchema" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the raw schema
 
 @return The raw schema.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The KeySchema type.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.KeySchema -->
  <!-- start class com.cloudera.cdk.data.dao.MappingType -->
  <class name="MappingType" extends="java.lang.Enum&lt;com.cloudera.cdk.data.dao.MappingType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.cloudera.cdk.data.dao.MappingType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.cloudera.cdk.data.dao.MappingType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The supported Mapping Types, which control how an entity field maps to
 columns in an HBase table.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.MappingType -->
  <!-- start class com.cloudera.cdk.data.dao.PartialKey -->
  <class name="PartialKey" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPartList" return="java.util.List&lt;com.cloudera.cdk.data.dao.PartialKey.KeyPartNameValue&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the list of KeyPartNameValues.
 
 @return The list of KeyPartNameValues that make this partial key.]]>
      </doc>
    </method>
    <method name="getKeyPartByName" return="com.cloudera.cdk.data.dao.PartialKey.KeyPartNameValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a part of the key by its name.
 
 @param name
          The name of the key part to get, or null if it doesn't exist.
 @return The KeyPartNameValue]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A partial key, which can be used to create table scanners that start from the
 bytes that make up only part of the key.
 
 @param <K>
          The Key type]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.PartialKey -->
  <!-- start class com.cloudera.cdk.data.dao.PartialKey.Builder -->
  <class name="PartialKey.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PartialKey.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="build" return="com.cloudera.cdk.data.dao.PartialKey&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addKeyPart" return="com.cloudera.cdk.data.dao.PartialKey.Builder&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="partName" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Builder for the PartialKey
 
 @param <K>]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.PartialKey.Builder -->
  <!-- start class com.cloudera.cdk.data.dao.PartialKey.KeyPartNameValue -->
  <class name="PartialKey.KeyPartNameValue" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PartialKey.KeyPartNameValue" type="java.lang.String, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A class that encapsulates a Key part. A Key part consists of a name value
 pair, where the name is of type String, and the value is an Object.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.PartialKey.KeyPartNameValue -->
  <!-- start interface com.cloudera.cdk.data.dao.SchemaManager -->
  <interface name="SchemaManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hasManagedSchema" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if this entity manager knows of a managed schema in the
 specified table that goes by the entityName.
 
 @param tableName
          The table name of the managed schema.
 @param entityName
          The entity name of the managed schema.
 @return True if it has it, false otherwise]]>
      </doc>
    </method>
    <method name="getKeySchema" return="com.cloudera.cdk.data.dao.KeySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the key schema for managed schema.
 
 @param tableName
          The table name of the managed schema.
 @param entityName
          The entity name of the managed schema.
 @return The key schema.
 @throws SchemaNotFoundException]]>
      </doc>
    </method>
    <method name="getEntitySchema" return="com.cloudera.cdk.data.dao.EntitySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the entity schema for the managed schema. This will return the entity
 schema with the greatest version.
 
 @param tableName
          The table name of the managed schema.
 @param entityName
          The entity name of the managed schema.
 @return The entity schema
 @throws SchemaNotFoundException]]>
      </doc>
    </method>
    <method name="getEntitySchema" return="com.cloudera.cdk.data.dao.EntitySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <param name="version" type="int"/>
      <doc>
      <![CDATA[Get a specified version of the entity schema for the managed schema.
 
 @param tableName
          The table name of the managed schema.
 @param entityName
          The entity name of the managed schema.
 @param version
          The version of the entity schema.
 @return The entity schema
 @throws SchemaNotFoundException]]>
      </doc>
    </method>
    <method name="getEntitySchemas" return="java.util.Map&lt;java.lang.Integer, com.cloudera.cdk.data.dao.EntitySchema&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <doc>
      <![CDATA[Get all entity schema versions for a managed schema identified by the table
 name and entity name.
 
 @param tableName
          The table name of the managed schema
 @param entityName
          The entity name of the managed schema
 @return The map of versioned entity schemas.]]>
      </doc>
    </method>
    <method name="getEntityVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <param name="schema" type="com.cloudera.cdk.data.dao.EntitySchema"/>
      <doc>
      <![CDATA[Function takes an entity schema, and the table name and entity name of a
 managed schema, and will return the version of that entity schema.
 
 @param tableName
          The table name of the managed schema.
 @param entityName
          The entity name of the managed schema.
 @param schema
          The entity schema, whose version this method will return.
 @return The entity schema's version
 @throws SchemaNotFoundException]]>
      </doc>
    </method>
    <method name="refreshManagedSchemaCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <doc>
      <![CDATA[Refresh the underlying ManagedSchema cache for a specific table name,
 entity name pair. This will ensure that calls to get key or entity schemas
 will return the latest data in the meta store.
 
 @param tableName
          The table name of the managed schema.
 @param entityName
          The entity name of the managed schema.]]>
      </doc>
    </method>
    <method name="createSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <param name="keySchemaStr" type="java.lang.String"/>
      <param name="entitySchemaStr" type="java.lang.String"/>
      <param name="schemaType" type="java.lang.String"/>
      <param name="keySerDeType" type="java.lang.String"/>
      <param name="entitySerDeType" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a new schema version. There must be no previous schema for this
 table/entity name pair.
 
 @param tableName
          The table name of the managed schema
 @param entityName
          The entity name of the managed schema
 @param keySchema
          The schema of the key being added
 @param entitySchema
          The schema of the entity being added
 @throws IncompatibleSchemaException
           if a previous schema exists
 @throws ConcurrentSchemaModificationException
 @throws SchemaValidationException]]>
      </doc>
    </method>
    <method name="migrateSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <param name="newSchema" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a new schema version. The new schema must be an allowed schema
 upgrade, which is dictated by the implementation.
 
 @param tableName
          The table name of the managed schema
 @param entityName
          The entity name of the managed schema
 @param newSchema
          The new schema
 @throws SchemaNotFoundException
 @throws IncompatibleSchemaException
 @throws ConcurrentSchemaModificationException
 @throws SchemaValidationException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for managing schemas with a meta store. This interface provides
 various methods for accessing the schema values in the meta store, as well as
 methods for creating or migrating new schemas.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.dao.SchemaManager -->
  <!-- start class com.cloudera.cdk.data.dao.SchemaNotFoundException -->
  <class name="SchemaNotFoundException" extends="com.cloudera.cdk.data.dao.HBaseCommonException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SchemaNotFoundException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SchemaNotFoundException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SchemaNotFoundException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.SchemaNotFoundException -->
  <!-- start class com.cloudera.cdk.data.dao.SchemaValidationException -->
  <class name="SchemaValidationException" extends="com.cloudera.cdk.data.dao.HBaseCommonException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SchemaValidationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SchemaValidationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SchemaValidationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.SchemaValidationException -->
  <!-- start class com.cloudera.cdk.data.dao.SerializationException -->
  <class name="SerializationException" extends="com.cloudera.cdk.data.dao.HBaseCommonException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SerializationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.cloudera.cdk.data.dao.SerializationException -->
</package>
<package name="com.cloudera.cdk.data.filesystem">
  <!-- start class com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository -->
  <class name="FileSystemDatasetRepository" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.DatasetRepository"/>
    <constructor name="FileSystemDatasetRepository" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a {@link FileSystemDatasetRepository} on the given {@link FileSystem} and
 root directory, and a {@link FileSystemMetadataProvider} with the same {@link
 FileSystem} and root directory.

 @param fileSystem    the filesystem to store metadata and datasets in
 @param rootDirectory the root directory for metadata and datasets]]>
      </doc>
    </constructor>
    <constructor name="FileSystemDatasetRepository" type="java.net.URI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a {@link FileSystemDatasetRepository} with a root directory at the
 given {@link URI}, and a {@link FileSystemMetadataProvider} with the same root
 directory.

 @param uri the root directory for metadata and datasets
 @since 0.3.0]]>
      </doc>
    </constructor>
    <constructor name="FileSystemDatasetRepository" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.fs.Path, com.cloudera.cdk.data.MetadataProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a {@link FileSystemDatasetRepository} on the given {@link FileSystem} and
 root directory, with the given {@link MetadataProvider} for metadata storage.

 @param fileSystem       the filesystem to store datasets in
 @param rootDirectory    the root directory for datasets
 @param metadataProvider the provider for metadata storage]]>
      </doc>
    </constructor>
    <method name="create" return="com.cloudera.cdk.data.Dataset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="descriptor" type="com.cloudera.cdk.data.DatasetDescriptor"/>
    </method>
    <method name="update" return="com.cloudera.cdk.data.Dataset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="descriptor" type="com.cloudera.cdk.data.DatasetDescriptor"/>
    </method>
    <method name="get" return="com.cloudera.cdk.data.Dataset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="drop" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="partitionKeyForPath" return="com.cloudera.cdk.data.PartitionKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="com.cloudera.cdk.data.Dataset"/>
      <param name="partitionPath" type="java.net.URI"/>
      <doc>
      <![CDATA[Get a {@link com.cloudera.cdk.data.PartitionKey} corresponding to a partition's filesystem path
 represented as a {@link URI}. If the path is not a valid partition,
 then {@link IllegalArgumentException} is thrown. Note that the partition does not
 have to exist.
 @param dataset the filesystem dataset
 @param partitionPath a directory path where the partition data is stored
 @return a partition key representing the partition at the given path
 @since 0.4.0]]>
      </doc>
    </method>
    <method name="pathForDataset" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[<p>
 Implementations should return the fully-qualified path of the data directory for
 the dataset with the given name.
 </p>
 <p>
 This method is for internal use only and users should not call it directly.
 </p>
 @since 0.2.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRootDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the root directory in the filesystem where datasets are stored.]]>
      </doc>
    </method>
    <method name="getFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the {@link FileSystem} on which datasets are stored.]]>
      </doc>
    </method>
    <method name="getMetadataProvider" return="com.cloudera.cdk.data.MetadataProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the {@link MetadataProvider} being used by this repository.
 @since 0.2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A {@link com.cloudera.cdk.data.DatasetRepository} that stores data in a Hadoop {@link FileSystem}.
 </p>
 <p>
 Given a {@link FileSystem}, a root directory, and a {@link com.cloudera.cdk.data.MetadataProvider},
 this {@link com.cloudera.cdk.data.DatasetRepository} implementation can load and store
 {@link com.cloudera.cdk.data.Dataset}s on both local filesystems as well as the Hadoop Distributed
 FileSystem (HDFS). Users may directly instantiate this class with the three
 dependencies above and then perform dataset-related operations using any of
 the provided methods. The primary methods of interest will be
 {@link #create(String, com.cloudera.cdk.data.DatasetDescriptor)}, {@link #get(String)}, and
 {@link #drop(String)} which create a new dataset, load an existing
 dataset, or delete an existing dataset, respectively. Once a dataset has been created
 or loaded, users can invoke the appropriate {@link com.cloudera.cdk.data.Dataset} methods to get a reader
 or writer as needed.
 </p>

 @see com.cloudera.cdk.data.DatasetRepository
 @see com.cloudera.cdk.data.Dataset
 @see com.cloudera.cdk.data.DatasetDescriptor
 @see com.cloudera.cdk.data.PartitionStrategy
 @see com.cloudera.cdk.data.MetadataProvider]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository -->
  <!-- start class com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository.Builder -->
  <class name="FileSystemDatasetRepository.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Supplier&lt;com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository&gt;"/>
    <constructor name="FileSystemDatasetRepository.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="rootDirectory" return="com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[The root directory for metadata and dataset files.]]>
      </doc>
    </method>
    <method name="rootDirectory" return="com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[The root directory for metadata and dataset files.]]>
      </doc>
    </method>
    <method name="fileSystem" return="com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileSystem" type="org.apache.hadoop.fs.FileSystem"/>
      <doc>
      <![CDATA[The {@link FileSystem} to store metadata and dataset files in. Optional. If not
 specified, the default filesystem will be used.]]>
      </doc>
    </method>
    <method name="metadataProvider" return="com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metadataProvider" type="com.cloudera.cdk.data.MetadataProvider"/>
      <doc>
      <![CDATA[The {@link MetadataProvider} for metadata storage. Optional. If not
 specified, a {@link FileSystemMetadataProvider} will be used.]]>
      </doc>
    </method>
    <method name="configuration" return="com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configuration" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[The {@link Configuration} used to find the {@link FileSystem}. Optional. If not
 specified, the default configuration will be used.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="get" return="com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A fluent builder to aid in the construction of {@link FileSystemDatasetRepository}
 instances.
 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.filesystem.FileSystemDatasetRepository.Builder -->
  <!-- start class com.cloudera.cdk.data.filesystem.FileSystemMetadataProvider -->
  <class name="FileSystemMetadataProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.MetadataProvider"/>
    <constructor name="FileSystemMetadataProvider" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="load" return="com.cloudera.cdk.data.DatasetDescriptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="descriptor" type="com.cloudera.cdk.data.DatasetDescriptor"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 A {@link MetadataProvider} that stores dataset metadata in a Hadoop
 {@link FileSystem}.
 </p>
 <p>
 When configured with a root directory, this implementation serializes the
 information within a {@link com.cloudera.cdk.data.DatasetDescriptor} on the provided
 {@link FileSystem}. The descriptor is serialized as an Avro object and stored
 in a directory named after the dataset name. For example, if the dataset name
 is {@code logs}, the directory {@code rootDirectory/logs/} will be created,
 if it doesn't exist, and the serialized descriptor will be stored in the file
 {@code descriptor.avro}.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.filesystem.FileSystemMetadataProvider -->
</package>
<package name="com.cloudera.cdk.data.flume">
  <!-- start class com.cloudera.cdk.data.flume.Log4jAppender -->
  <class name="Log4jAppender" extends="org.apache.flume.clients.log4jappender.Log4jAppender"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Log4jAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Log4jAppender" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the hostname and port. Even if these are passed the
 <tt>activateOptions()</tt> function must be called before calling
 <tt>append()</tt>, else <tt>append()</tt> will throw an Exception.
 @param hostname The first hop where the client should connect to.
 @param port The port to connect on the host.]]>
      </doc>
    </constructor>
    <method name="setDatasetRepositoryClass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="datasetRepositoryClass" type="java.lang.String"/>
    </method>
    <method name="setDatasetRepositoryUri"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="datasetRepositoryUri" type="java.lang.String"/>
    </method>
    <method name="setDatasetName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="datasetName" type="java.lang.String"/>
    </method>
    <method name="populateAvroHeaders"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="hdrs" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <param name="schema" type="org.apache.avro.Schema"/>
      <param name="message" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.flume.Log4jAppender -->
</package>
<package name="com.cloudera.cdk.data.hbase">
  <!-- start class com.cloudera.cdk.data.hbase.BaseDao -->
  <class name="BaseDao" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.dao.Dao&lt;K, E&gt;"/>
    <constructor name="BaseDao" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor that will internally create an HBaseClientTemplate from the
 tablePool and the tableName.
 
 @param transactionManager
          The TransactionManager that will manage transactional entities.
 @param tablePool
          A pool of HBase Tables.
 @param tableName
          The name of the table this dao persists to and fetches from.
 @param entityMapper
          Maps between entities and the HBase operations.]]>
      </doc>
    </constructor>
    <constructor name="BaseDao" type="com.cloudera.cdk.data.hbase.BaseDao&lt;K, E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor that copies an existing dao.
 
 @param dao
          Dao to copy.]]>
      </doc>
    </constructor>
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
    </method>
    <method name="increment" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="fieldName" type="java.lang.String"/>
      <param name="amount" type="long"/>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
    </method>
    <method name="getScanner" return="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getScanner" return="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startKey" type="K"/>
      <param name="stopKey" type="K"/>
    </method>
    <method name="getScanner" return="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startKey" type="com.cloudera.cdk.data.dao.PartialKey&lt;K&gt;"/>
      <param name="stopKey" type="com.cloudera.cdk.data.dao.PartialKey&lt;K&gt;"/>
    </method>
    <method name="getScannerBuilder" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newBatch" return="com.cloudera.cdk.data.dao.EntityBatch&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeBufferSize" type="long"/>
    </method>
    <method name="newBatch" return="com.cloudera.cdk.data.dao.EntityBatch&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHBaseClientTemplate" return="com.cloudera.cdk.data.hbase.HBaseClientTemplate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the HBaseClientTemplate instance this DAO is using to interact with
 HBase.
 
 @return The HBaseClientTemplate instance.]]>
      </doc>
    </method>
    <method name="getKeySchema" return="com.cloudera.cdk.data.dao.KeySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntitySchema" return="com.cloudera.cdk.data.dao.EntitySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeySerDe" return="com.cloudera.cdk.data.hbase.KeySerDe&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key serde for this DAO

 @return The KeySerDe]]>
      </doc>
    </method>
    <method name="getEntitySerDe" return="com.cloudera.cdk.data.hbase.EntitySerDe&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity serde for this DAO

 @return The EntitySerDe]]>
      </doc>
    </method>
    <method name="getEntityMapper" return="com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the EntityMapper for this DAO.

 @return EntityMapper]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A DAO implementation that uses a constructor provided EntityMapper to do
 basic conversion between entities and HBase Gets and Puts.
 
 @param <K>
          The key type
 @param <E>
          The entity type.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.BaseDao -->
  <!-- start class com.cloudera.cdk.data.hbase.BaseEntityBatch -->
  <class name="BaseEntityBatch" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.dao.EntityBatch&lt;K, E&gt;"/>
    <constructor name="BaseEntityBatch" type="com.cloudera.cdk.data.hbase.HBaseClientTemplate, com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;, org.apache.hadoop.hbase.client.HTablePool, java.lang.String, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks an HTable out of the HTablePool and modifies it to take advantage of
 batch puts. This is very useful when performing many consecutive puts.

 @param clientTemplate
          The client template to use
 @param entityMapper
          The EntityMapper to use for mapping
 @param pool
          The HBase table pool
 @param tableName
          The name of the HBase table
 @param writeBufferSize
          The batch buffer size in bytes.]]>
      </doc>
    </constructor>
    <constructor name="BaseEntityBatch" type="com.cloudera.cdk.data.hbase.HBaseClientTemplate, com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;, org.apache.hadoop.hbase.client.HTablePool, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks an HTable out of the HTablePool and modifies it to take advantage of
 batch puts using the default writeBufferSize (2MB). This is very useful
 when performing many consecutive puts.

 @param clientTemplate
          The client template to use
 @param entityMapper
          The EntityMapper to use for mapping
 @param pool
          The HBase table pool
 @param tableName
          The name of the HBase table]]>
      </doc>
    </constructor>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.BaseEntityBatch -->
  <!-- start class com.cloudera.cdk.data.hbase.BaseEntityMapper -->
  <class name="BaseEntityMapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"/>
    <constructor name="BaseEntityMapper" type="com.cloudera.cdk.data.dao.KeySchema, com.cloudera.cdk.data.dao.EntitySchema, com.cloudera.cdk.data.hbase.KeySerDe&lt;K&gt;, com.cloudera.cdk.data.hbase.EntitySerDe&lt;E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="mapToEntity" return="com.cloudera.cdk.data.dao.KeyEntity&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.apache.hadoop.hbase.client.Result"/>
    </method>
    <method name="mapFromEntity" return="com.cloudera.cdk.data.hbase.PutAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
    </method>
    <method name="mapToIncrement" return="org.apache.hadoop.hbase.client.Increment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="fieldName" type="java.lang.String"/>
      <param name="amount" type="long"/>
    </method>
    <method name="mapFromIncrementResult" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.apache.hadoop.hbase.client.Result"/>
      <param name="fieldName" type="java.lang.String"/>
    </method>
    <method name="getRequiredColumns" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRequiredColumnFamilies" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeySchema" return="com.cloudera.cdk.data.dao.KeySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntitySchema" return="com.cloudera.cdk.data.dao.EntitySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeySerDe" return="com.cloudera.cdk.data.hbase.KeySerDe&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntitySerDe" return="com.cloudera.cdk.data.hbase.EntitySerDe&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntityComposer" return="com.cloudera.cdk.data.hbase.EntityComposer&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A base implementation of EntityMapper, that uses the provided
 EntitySerDe and KeyBuilderFactory to map Key/Entity pairs to
 HBase puts, and HBase results to KeyEntity pairs.

 @param <K> The key type
 @param <E> The entity type]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.BaseEntityMapper -->
  <!-- start class com.cloudera.cdk.data.hbase.BaseEntityScanner -->
  <class name="BaseEntityScanner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"/>
    <constructor name="BaseEntityScanner" type="org.apache.hadoop.hbase.client.Scan, org.apache.hadoop.hbase.client.HTablePool, java.lang.String, com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param scan
          The Scan object that will be used
 @param transactionManager
          The TransactionManager that will manage transactional entities.
 @param tablePool
          The HTablePool instance to get a table to open a scanner on.
 @param tableName
          The table name to perform the scan on.
 @param entityMapper
          The EntityMapper to map rows to entities.
 @param transactional
          true if this is a transactional scan.]]>
      </doc>
    </constructor>
    <method name="iterator" return="java.util.Iterator&lt;com.cloudera.cdk.data.dao.KeyEntity&lt;K, E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="open"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base EntityScanner implementation. This EntityScanner will use an
 EntityMapper while scanning rows in HBase, and will map each row to KeyEntity
 pairs.
 
 @param <K>
          The underlying key record type.
 @param <E>
          The entity type this scanner scans.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.BaseEntityScanner -->
  <!-- start class com.cloudera.cdk.data.hbase.BaseEntityScanner.Builder -->
  <class name="BaseEntityScanner.Builder" extends="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BaseEntityScanner.Builder" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="build" return="com.cloudera.cdk.data.hbase.BaseEntityScanner&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Scanner builder for BaseEntityScanner
 
 @param <K>
 @param <E>]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.BaseEntityScanner.Builder -->
  <!-- start class com.cloudera.cdk.data.hbase.CompositeBaseDao -->
  <class name="CompositeBaseDao" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.hbase.CompositeDao&lt;K, E, S&gt;"/>
    <constructor name="CompositeBaseDao" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, java.util.List&lt;com.cloudera.cdk.data.hbase.EntityMapper&lt;K, S&gt;&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor that will internally create an HBaseClientTemplate from the
 tablePool and the tableName.
 
 @param tablePool
          A pool of HBase Tables.
 @param tableName
          The name of the table this dao persists to and fetches from.
 @param entityMappers
          Maps between entities and the HBase operations for their
          respective sub entities.]]>
      </doc>
    </constructor>
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
    </method>
    <method name="increment" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="fieldName" type="java.lang.String"/>
      <param name="amount" type="long"/>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
    </method>
    <method name="getScanner" return="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getScanner" return="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startKey" type="K"/>
      <param name="stopKey" type="K"/>
    </method>
    <method name="getScanner" return="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startKey" type="com.cloudera.cdk.data.dao.PartialKey&lt;K&gt;"/>
      <param name="stopKey" type="com.cloudera.cdk.data.dao.PartialKey&lt;K&gt;"/>
    </method>
    <method name="getKeySchema" return="com.cloudera.cdk.data.dao.KeySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntitySchema" return="com.cloudera.cdk.data.dao.EntitySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newBatch" return="com.cloudera.cdk.data.dao.EntityBatch&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeBufferSize" type="long"/>
    </method>
    <method name="newBatch" return="com.cloudera.cdk.data.dao.EntityBatch&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base implementation of the CompositeDao interface. Internally managed
 multiple EntityMappers that each handle their respective sub types.
 
 @param <K>
          The type of the key
 @param <E>
          The type of the entity this DAO returns. This entity will be a
          composition of the sub entities.
 @param <S>
          The type of the sub entities.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.CompositeBaseDao -->
  <!-- start interface com.cloudera.cdk.data.hbase.CompositeDao -->
  <interface name="CompositeDao"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.dao.Dao&lt;K, E&gt;"/>
    <method name="compose" return="com.cloudera.cdk.data.dao.KeyEntity&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyEntities" type="java.util.List&lt;com.cloudera.cdk.data.dao.KeyEntity&lt;K, S&gt;&gt;"/>
      <doc>
      <![CDATA[Compose an entity from the list of sub-entities.
 
 @param keyEntities The list of sub-entities
 @return The KeyEntity instance which contains the composed entity.]]>
      </doc>
    </method>
    <method name="decompose" return="java.util.List&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="E"/>
      <doc>
      <![CDATA[Decompose an entity into multiple sub entities.
 
 @param entity The entity to decompose
 @return The list of subentities.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The CompositeDao provides an interface for fetching from tables that may have
 multiple entities stored per row.
 
 The concept is that one entity can be composed from a list of KeyEntities
 that make up the row, and that one entity can be decomposed into multiple sub
 entities that can be persisted to the row.
 
 @param <K>
          The type of the key
 @param <E>
          The type of the entity this dao returns. This entity will be a
          composition of the sub entities.
 @param <S>
          The type of the sub entities.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.CompositeDao -->
  <!-- start class com.cloudera.cdk.data.hbase.DeleteAction -->
  <class name="DeleteAction" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DeleteAction" type="org.apache.hadoop.hbase.client.Delete"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DeleteAction" type="org.apache.hadoop.hbase.client.Delete, com.cloudera.cdk.data.hbase.VersionCheckAction"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDelete" return="org.apache.hadoop.hbase.client.Delete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVersionCheckAction" return="com.cloudera.cdk.data.hbase.VersionCheckAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setVersionCheckAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionCheckAction" type="com.cloudera.cdk.data.hbase.VersionCheckAction"/>
    </method>
    <doc>
    <![CDATA[Represents a Delete. This simple class encapsulates both a Delete, and a
 CheckAction operation, which allows us to do checkAndDelete.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.DeleteAction -->
  <!-- start interface com.cloudera.cdk.data.hbase.DeleteActionModifier -->
  <interface name="DeleteActionModifier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="modifyDeleteAction" return="com.cloudera.cdk.data.hbase.DeleteAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deleteAction" type="com.cloudera.cdk.data.hbase.DeleteAction"/>
      <doc>
      <![CDATA[Modify the DeleteAction instance.
 
 @param deleteAction
          The DeleteAction instance to modify.
 @return The modified DeleteAction]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Generic callback interface used by HBaseClientTemplate class. This interface
 modifies a Delete instance before the HBaseClientTemplate executes it on the
 HBase table.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.DeleteActionModifier -->
  <!-- start interface com.cloudera.cdk.data.hbase.EntityComposer -->
  <interface name="EntityComposer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getBuilder" return="com.cloudera.cdk.data.hbase.EntityComposer.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an Entity Builder that can build Entity types for this composer.
 
 @return The entity builder.]]>
      </doc>
    </method>
    <method name="extractField" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="E"/>
      <param name="fieldName" type="java.lang.String"/>
      <doc>
      <![CDATA[Extract a field from the entity by name
 
 @param entity
          The entity to extract a field from.
 @param fieldName
          The name of the field to extract
 @return The field value]]>
      </doc>
    </method>
    <method name="extractKeyAsColumnValues" return="java.util.Map&lt;java.lang.CharSequence, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="fieldValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Transform the keyAsColumn field value into a Map
 
 @param fieldName
          The name of the keyAsColumn field.
 @param value
          The value of the entities field specified by field name. The value
          can be any type the implementation supports for keyAsColumn fields
 @return The keyAsColumn field value as a map]]>
      </doc>
    </method>
    <method name="buildKeyAsColumnField" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="keyAsColumnValues" type="java.util.Map&lt;java.lang.CharSequence, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Build a keyAsColumn field for the entity from a map of keyAsColumn values.
 This is the inverse of extractKeyAsColumnValues. It will turn the map into
 the type the entity uses for its keyAsColumn field.
 
 @param fieldName
          The name of the field
 @param keyAsColumnValues
          The map of keyAsColumn values.
 @return The field value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An EntityComposer is an interface that supports entity construction and
 de-construction methods. This includes getting a Builder for an entity,
 building keyAsColumn field values, and extracting fields and keyAsColumn
 fields.
 
 These are basically all methods an EntityMapper would need to do the entity
 record construction/de-construction from HBase column values.
 
 @param <E>
          The type of entity this composer works with.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.EntityComposer -->
  <!-- start interface com.cloudera.cdk.data.hbase.EntityComposer.Builder -->
  <interface name="EntityComposer.Builder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="put" return="com.cloudera.cdk.data.hbase.EntityComposer.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Put a field value into the entity.
 
 @param fieldName
          The name of the field
 @param value
          The value of the field
 @return A reference to the Builder, so puts can be chained.]]>
      </doc>
    </method>
    <method name="build" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds the entity, and returns it.
 
 @return The built entity]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface for entity builders.
 
 @param <E>
          The type of the entity this builder builds.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.EntityComposer.Builder -->
  <!-- start interface com.cloudera.cdk.data.hbase.EntityMapper -->
  <interface name="EntityMapper"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="mapToEntity" return="com.cloudera.cdk.data.dao.KeyEntity&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.apache.hadoop.hbase.client.Result"/>
      <doc>
      <![CDATA[Map an HBase Result instance to an Entity of type T. Retrieve the Key from
 the result instance as well, and wraps both in an KeyEntity instance. This
 KeyEntity instance is returned.
 
 @param result
          The HBase result instance representing a row from an HBase table.
 @return A KeyEntity instance which wraps a Key and an Entity of type T.]]>
      </doc>
    </method>
    <method name="mapFromEntity" return="com.cloudera.cdk.data.hbase.PutAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
      <doc>
      <![CDATA[Map a Key and an entity of type T to an HBase Put instance.
 
 @param key
          a key to use to construct the Put instance.
 @param entity
          The entity which this function will map to a Put instance.
 @return An HBase Put.]]>
      </doc>
    </method>
    <method name="mapToIncrement" return="org.apache.hadoop.hbase.client.Increment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="fieldName" type="java.lang.String"/>
      <param name="amount" type="long"/>
      <doc>
      <![CDATA[Maps a Key, fieldName and an increment value to an HBase Increment instance
 that will increment the value in the cell pointed to by fieldName.
 
 @param key
          a key to use to construct the Increment instance.
 @param fieldName
          The name of the field we are incrementing
 @param amount
          The amount to increment the field by
 @return An HBase Increment]]>
      </doc>
    </method>
    <method name="mapFromIncrementResult" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.apache.hadoop.hbase.client.Result"/>
      <param name="fieldName" type="java.lang.String"/>
      <doc>
      <![CDATA[Maps the result of an increment to the new value of the field that was
 incremented.
 
 @param result
          The HBase client Result object that contains the increment result
 @param fieldName
          The name of the field we are getting the increment result for
 @return The new field value.]]>
      </doc>
    </method>
    <method name="getRequiredColumns" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the set of required HBase columns that we would expect to be in the
 result.
 
 @return The set of required columns.]]>
      </doc>
    </method>
    <method name="getRequiredColumnFamilies" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the set of required column families that must exist in the HBase table
 we would be mapping from.
 
 @return The set of required column families.]]>
      </doc>
    </method>
    <method name="getKeySchema" return="com.cloudera.cdk.data.dao.KeySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key schema instance for this entity mapper.
 
 @return The HBaseCommonKeySchema instance.]]>
      </doc>
    </method>
    <method name="getEntitySchema" return="com.cloudera.cdk.data.dao.EntitySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity schema instance for this entity mapper.
 
 @return The HBaseCommonEntitySchema instance.]]>
      </doc>
    </method>
    <method name="getKeySerDe" return="com.cloudera.cdk.data.hbase.KeySerDe&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key serde instance for this entity mapper
 
 @return The key serde for the entity mapper]]>
      </doc>
    </method>
    <method name="getEntitySerDe" return="com.cloudera.cdk.data.hbase.EntitySerDe&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity serde instance for this entity mapper
 
 @return The entity serde for the entity mapper]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface for mapping HBase Result instances to a Key/Entity pair, and a
 Key/Entity to an HBase Put instances.
 
 EntityMapper instances should be state-less so they can be reused across
 multiple Result and Entity instances. They should encapsulate in one place
 the mapping of business entities to and from HBase.
 
 @param <K>
          The underlying key record type.
 @param <E>
          The entity type]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.EntityMapper -->
  <!-- start class com.cloudera.cdk.data.hbase.EntityScannerBuilder -->
  <class name="EntityScannerBuilder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityScannerBuilder" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is an abstract Builder object for the Entity Scanners, which will
 allow users to dynamically construct a scanner object using the Builder
 pattern. This is useful when the user doesn't have all the up front
 information to create a scanner. It's also easier to add more options later
 to the scanner, this will be the preferred method for users to create
 scanners.
 
 @param <K>
          The underlying key record type.
 @param <E>
          The entity type this scanner scans.]]>
      </doc>
    </constructor>
    <method name="setStartKey" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startKey" type="K"/>
      <doc>
      <![CDATA[Set The Start Key. If the partialStartKey has already been set, it will be
 reset to null.
 
 @param startKey
          The start key for this scan
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="setPartialStartKey" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="partialStartKey" type="com.cloudera.cdk.data.dao.PartialKey&lt;K&gt;"/>
      <doc>
      <![CDATA[Set The Partial Start Key. If the startKey has already been set, it will be
 reset to null.
 
 @param partialStartKey
          The start key for this scan
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="setStopKey" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stopKey" type="K"/>
      <doc>
      <![CDATA[Set The Stop Key. If a partialStopKey has already been set, it will be
 reset to null.
 
 @param stopKey
          The stop key for this scan
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="setPartialStopKey" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="partialStopKey" type="com.cloudera.cdk.data.dao.PartialKey&lt;K&gt;"/>
      <doc>
      <![CDATA[Set The Partial Stop Key. If the stopKey has already been set, it will be
 reset to null.
 
 @param partialStopKey
          The stop key for this scan
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="setCaching" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="caching" type="int"/>
      <doc>
      <![CDATA[Set The Scanner Caching Level
 
 @param caching
          caching amount for scanner
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="addEqualFilter" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="filterValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Add an Equality Filter to the Scanner, Will Filter Results Not Equal to the
 Filter Value
 
 @param fieldName
          The name of the column you want to apply the filter on
 @param filterValue
          The value for comparison
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="addNotEqualFilter" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="filterValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Add an Inequality Filter to the Scanner, Will Filter Results Not Equal to
 the Filter Value
 
 @param fieldName
          The name of the column you want to apply the filter on
 @param filterValue
          The value for comparison
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="addRegexMatchFilter" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="regexString" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a Regex Equality Filter to the Scanner, Will Filter Results Not Equal
 to the Filter Value
 
 @param fieldName
          The name of the column you want to apply the filter on
 @param filterValue
          The regular expression to use for comparison
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="addRegexNotMatchFilter" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="regexString" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a Regex Inequality Filter to the Scanner, Will Filter Results Not Equal
 to the Filter Value
 
 @param fieldName
          The name of the column you want to apply the filter on
 @param filterValue
          The regular expression to use for comparison
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="addNotNullFilter" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <doc>
      <![CDATA[Do not include rows which have no value for fieldName
 
 @param fieldName
          The field to check nullity
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="addIsNullFilter" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <doc>
      <![CDATA[Only include rows which have an empty value for this field
 
 @param fieldName
          The field to check nullity
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="addIsMissingFilter" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <doc>
      <![CDATA[Only include rows which are missing this field, this was the only possible
 way to do it.
 
 @param fieldName
          The field which should be missing
 @return ScannerBuilder]]>
      </doc>
    </method>
    <method name="setPassAllFilters" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="passAllFilters" type="boolean"/>
    </method>
    <method name="addFilter" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="com.cloudera.cdk.data.hbase.filters.EntityFilter"/>
      <doc>
      <![CDATA[Add HBase Filter To Scan Object
 
 @param filter
          EntityFilter object created by user]]>
      </doc>
    </method>
    <method name="addScanModifier" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scanModifier" type="com.cloudera.cdk.data.hbase.ScanModifier"/>
      <doc>
      <![CDATA[Add the ScanModifier to the list of ScanModifiers.
 
 @param scanModifier
          The ScanModifier to add]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.dao.EntityScanner&lt;K, E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Build, open and return a EntityScanner object using all of the information
 the user provided.
 
 @return ScannerBuilder]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An abstract class that EntityScanner implementations should extend to offer a
 builder interface. Implementations only need to implement the build method.
 
 @param <K>
          The underlying key record type
 @param <E>
          The entity type this canner scans]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.EntityScannerBuilder -->
  <!-- start class com.cloudera.cdk.data.hbase.EntitySerDe -->
  <class name="EntitySerDe" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntitySerDe" type="com.cloudera.cdk.data.hbase.EntityComposer&lt;E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="serialize" return="com.cloudera.cdk.data.hbase.PutAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyBytes" type="byte[]"/>
      <param name="fieldMapping" type="com.cloudera.cdk.data.dao.EntitySchema.FieldMapping"/>
      <param name="fieldValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Serialize an entity's field value to a PutAction.
 
 @param keyBytes
          The bytes of the serialized key (needed to construct a PutAction).
 @param fieldMapping
          The FieldMapping that specifies this field's mapping type and
          field name.
 @param fieldValue
          The value of the field to serialize.
 @return The PutAction with column's populated with the field's serialized
         values.]]>
      </doc>
    </method>
    <method name="deserialize" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldMapping" type="com.cloudera.cdk.data.dao.EntitySchema.FieldMapping"/>
      <param name="result" type="org.apache.hadoop.hbase.client.Result"/>
      <doc>
      <![CDATA[Deserialize an entity field from the HBase Result.
 
 @param fieldMapping
          The FieldMapping that specifies this field's mapping type and
          field name.
 @param result
          The HBase Result that represents a row in HBase.
 @return The field Object we deserialized from the Result.]]>
      </doc>
    </method>
    <method name="serializeColumnValueToBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="fieldValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Serialize the column mapped entity field value to bytes.
 
 @param fieldName
          The name of the entity's field
 @param fieldValue
          The value to serialize
 @return The serialized bytes]]>
      </doc>
    </method>
    <method name="serializeKeyAsColumnValueToBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="columnKey" type="java.lang.CharSequence"/>
      <param name="keyAsColumnFieldValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Serialize a value from a keyAsColumn entity field. The value is keyed on
 the key.
 
 @param fieldName
          The name of the entity's keyAsColumn field
 @param columnKey
          The key of the keyAsColumn field
 @param keyAsColumnFieldValue
          The value pointed to by this key.
 @return The serialized bytes]]>
      </doc>
    </method>
    <method name="serializeKeyAsColumnKeyToBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="columnKey" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Serialize the keyAsColumn key to bytes.
 
 @param fieldName
          The name of the entity's keyAsColumn field
 @param columnKey
          The column key to serialize to bytes
 @return The serialized bytes.]]>
      </doc>
    </method>
    <method name="deserializeColumnValueFromBytes" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="columnBytes" type="byte[]"/>
      <doc>
      <![CDATA[Deserialize a column mapped entity field's bytes to its type.
 
 @param fieldName
          The name of the entity's field
 @param columnBytes
          The bytes to deserialize
 @return The field value we've deserialized.]]>
      </doc>
    </method>
    <method name="deserializeKeyAsColumnValueFromBytes" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="columKeyBytes" type="byte[]"/>
      <param name="columnValueBytes" type="byte[]"/>
      <doc>
      <![CDATA[Deserialize a value from a keyAsColumn entity field. The value is keyed on
 key.
 
 @param fieldName
          The name of the entity's keyAsColumn field
 @param columnKeyBytes
          The key bytes of the keyAsColumn field
 @param columnValueBytes
          The value bytes to deserialize
 @return The keyAsColumn value pointed to by key.]]>
      </doc>
    </method>
    <method name="deserializeKeyAsColumnKeyFromBytes" return="java.lang.CharSequence"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="columnKeyBytes" type="byte[]"/>
      <doc>
      <![CDATA[Deserialize the keyAsColumn key from the qualifier.
 
 @param fieldName
          The name of the keyAsColumn field
 @param columnKeyBytes
          The bytes of the qualifier
 @return The deserialized CharSequence]]>
      </doc>
    </method>
    <method name="getEntityComposer" return="com.cloudera.cdk.data.hbase.EntityComposer&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the EntityComposer this EntitySerDe uses to compose entity fields.
 
 @return The EntityComposer]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class handles entity serialization and deserialization. It's able to
 serialize fields of an entity to PutActions.
 
 @param <E>
          The type of the entity]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.EntitySerDe -->
  <!-- start interface com.cloudera.cdk.data.hbase.GetModifier -->
  <interface name="GetModifier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="modifyGet" return="org.apache.hadoop.hbase.client.Get"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="get" type="org.apache.hadoop.hbase.client.Get"/>
      <doc>
      <![CDATA[Modify the Get instance.
 
 @param get
          The Get instance to modify.
 @return The modified Get instance]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Generic callback interface used by HBaseClientTemplate class. This interface
 modifies a Get instance before the HBaseClientTemplate executes it on the
 HBase table.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.GetModifier -->
  <!-- start class com.cloudera.cdk.data.hbase.HBaseClientTemplate -->
  <class name="HBaseClientTemplate" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HBaseClientTemplate" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct an HBaseClientTemplate. Requires an HTablePool to acquire HBase
 connections from, and the name of the table to interact with.
 
 @param pool
          The pool of HBase connections.
 @param tableName
          The name of the table to interact with.]]>
      </doc>
    </constructor>
    <constructor name="HBaseClientTemplate" type="com.cloudera.cdk.data.hbase.HBaseClientTemplate"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a client template that is a copy of an existing client template.
 
 @param clientTemplate]]>
      </doc>
    </constructor>
    <method name="registerGetModifier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="getModifier" type="com.cloudera.cdk.data.hbase.GetModifier"/>
      <doc>
      <![CDATA[Register a GetModifier to be called before every Get is executed on HBase.
 Multiple GetModifiers can be registered by invoking this function multiple
 times. GetModifiers will be called in the order they are added to the
 template, so if any modifier is destructive, it must be added in the right
 order.
 
 @param getModifier
          The GetModifier to register.]]>
      </doc>
    </method>
    <method name="registerPutActionModifier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="putActionModifier" type="com.cloudera.cdk.data.hbase.PutActionModifier"/>
      <doc>
      <![CDATA[Register a PutActionModifier to be called before every Put is executed on
 HBase. Multiple PutActionModifiers can be registered by invoking this
 function multiple times. PutActionModifiers will be called in the order
 they are added to the template, so if any modifier is destructive, it must
 be added in the right order.
 
 @param putActionModifier
          The PutActionModifier to register.]]>
      </doc>
    </method>
    <method name="registerUniquePutActionModifier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="putActionModifier" type="com.cloudera.cdk.data.hbase.PutActionModifier"/>
      <doc>
      <![CDATA[Registers a PutActionModifier to be called before every Put, if the given
 modifier is not already registered. This allows the user to prevent adding
 the same modifier multiple times.
 
 @param putActionModifier]]>
      </doc>
    </method>
    <method name="countPutActionModifiers" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerDeleteModifier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deleteActionModifier" type="com.cloudera.cdk.data.hbase.DeleteActionModifier"/>
      <doc>
      <![CDATA[Register a DeleteActionModifier to be called before every Delete is
 executed on HBase. Multiple DeleteActionModifiers can be registered by
 invoking this function multiple times. DeleteActionModifiers will be called
 in the order they are added to the template, so if any modifier is
 destructive, it must be added in the right order.
 
 @param deleteActionModifier
          The DeleteActionModifier to register.]]>
      </doc>
    </method>
    <method name="registerScanModifier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scanModifier" type="com.cloudera.cdk.data.hbase.ScanModifier"/>
      <doc>
      <![CDATA[Register a ScanModifier to be called before every Scan is executed on
 HBase. Multiple ScanModifiers can be registered by invoking this function
 multiple times. ScanModifiers will be called in the order they are added to
 the template, so if any modifier is destructive, it must be added in the
 right order.
 
 @param scanModifier
          The ScanModifier to register.]]>
      </doc>
    </method>
    <method name="clearGetModifiers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear all GetModifiers registered with registerGetModifier.]]>
      </doc>
    </method>
    <method name="clearPutActionModifiers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear all PutActionModifiers registered with registerPutActionModifier.]]>
      </doc>
    </method>
    <method name="clearDeleteActionModifiers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear all DeleteActionModifiers registered with
 registerDeleteActionModifier.]]>
      </doc>
    </method>
    <method name="clearScanModifiers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear all ScanModifiers registered with registerScanModifier.]]>
      </doc>
    </method>
    <method name="clearAllModifiers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear all modifiers registered with the template for all operations.]]>
      </doc>
    </method>
    <method name="getTableName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the table name
 
 @return The table name]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.hbase.client.Result"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="get" type="org.apache.hadoop.hbase.client.Get"/>
      <doc>
      <![CDATA[Execute a Get on HBase.
 
 Any GetModifers registered with registerGetModifier will be invoked before
 the Get is executed.
 
 @param get
          The Get to execute
 @return Result returned from the Get.]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.hbase.client.Result"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="get" type="org.apache.hadoop.hbase.client.Get"/>
      <param name="getModifier" type="com.cloudera.cdk.data.hbase.GetModifier"/>
      <doc>
      <![CDATA[Execute the get on HBase, invoking the getModifier before executing the get
 if getModifier is not null.
 
 Any GetModifers registered with registerGetModifier will be invoked before
 the Get is executed, and after the getModifier passed to this function are
 called.
 
 @param get
          The Get to execute.
 @param getModifier
          Invoked before the Get to give callers a chance to modify the Get
          before it is executed.
 @return Result returned from the Get.]]>
      </doc>
    </method>
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entityMapper" type="com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"/>
      <doc>
      <![CDATA[Execute a Get on HBase, creating the Get from the key's toByteArray method.
 The returned Result of the Get will be mapped to an entity with the
 entityMapper, and that entity will be returned.
 
 Any GetModifers registered with registerGetModifier will be invoked before
 the Get is executed.
 
 @param key
          The Key to create a Get from.
 @param entityMapper
          The EntityMapper to use to map the Result to an entity to return.
 @return The entity created by the entityMapper.]]>
      </doc>
    </method>
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="getModifier" type="com.cloudera.cdk.data.hbase.GetModifier"/>
      <param name="entityMapper" type="com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"/>
      <doc>
      <![CDATA[Execute a Get on HBase, creating the Get from the key's toByteArray method.
 The returned Result of the Get will be mapped to an entity with the
 entityMapper, and that entity will be returned.
 
 If the getModifier is not null, it will be invoked before the created Get
 is executed.
 
 Any GetModifers registered with registerGetModifier will be invoked after
 the getModifier passed to this method is invoked, and before the Get is
 executed.
 
 @param key
          The Key to create a Get from.
 @param getModifier
          Invoked before the Get to give callers a chance to modify the Get
          before it is executed.
 @param entityMapper
          The EntityMapper to use to map the Result to an entity to return.
 @return The entity created by the entityMapper.]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="putAction" type="com.cloudera.cdk.data.hbase.PutAction"/>
      <doc>
      <![CDATA[Execute a Put on HBase.
 
 Any PutModifers registered with registerPutModifier will be invoked before
 the Put is executed.
 
 @param putAction
          The put to execute on HBase.
 @return True if the put succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="putAction" type="com.cloudera.cdk.data.hbase.PutAction"/>
      <param name="table" type="org.apache.hadoop.hbase.client.HTableInterface"/>
      <doc>
      <![CDATA[Execute a Put on HBase using a pre-define HTableInterface
 
 Any PutModifers registered with registerPutModifier will be invoked before
 the Put is executed.
 
 @param putAction
          The put to execute on HBase.
 @param table
          The HTableInterface object to interface with
 @return True if the put succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="putAction" type="com.cloudera.cdk.data.hbase.PutAction"/>
      <param name="putActionModifier" type="com.cloudera.cdk.data.hbase.PutActionModifier"/>
      <doc>
      <![CDATA[Execute the put on HBase, invoking the putModifier before executing the put
 if putModifier is not null.
 
 Any PutModifers registered with registerPutModifier will be invoked after
 the putModifier passed to this method is invoked, and before the Put is
 executed.
 
 @param putAction
          The PutAction to execute on HBase.
 @param putActionModifier
          Invoked before the Put to give callers a chance to modify the Put
          before it is executed.
 @return True if the put succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
      <param name="entityMapper" type="com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"/>
      <doc>
      <![CDATA[Execute a Put on HBase, creating the Put by mapping the key and entity to a
 Put with the entityMapper.
 
 Any PutModifers registered with registerPutModifier will be invoked before
 the Put is executed.
 
 @param key
          The Key to map to a Put with the entityMapper.
 @param entity
          The entity to map to a Put with the entityMapper.
 @param entityMapper
          The EntityMapper to map the key and entity to a put.
 @return True if the put succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="entity" type="E"/>
      <param name="putActionModifier" type="com.cloudera.cdk.data.hbase.PutActionModifier"/>
      <param name="entityMapper" type="com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"/>
      <doc>
      <![CDATA[Execute a Put on HBase, creating the Put by mapping the key and entity to a
 Put with the entityMapper. putModifier will be invoked on this created Put
 before the Put is executed.
 
 Any PutModifers registered with registerPutModifier will be invoked after
 the putModifier passed to this method is invoked, and before the Put is
 executed.
 
 @param key
          The Key to map to a Put with the entityMapper.
 @param entity
          The entity to map to a Put with the entityMapper.
 @param putActionModifier
          Invoked before the Put to give callers a chance to modify the Put
          before it is executed.
 @param entityMapper
          The EntityMapper to map the key and entity to a put.
 @return True if the put succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="increment" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="fieldName" type="java.lang.String"/>
      <param name="amount" type="long"/>
      <param name="entityMapper" type="com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"/>
      <doc>
      <![CDATA[Execute an increment on an entity field. This field must be a type that
 supports increments. Returns the new increment value of type long.
 
 @param key
          The key to map to an Increment
 @param fieldName
          The name of the field we are incrementing
 @param amount
          The amount to increment by
 @param entityMapper
          The EntityMapper to map the key and increment amount to an
          Increment.
 @return The new field amount after the increment.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deleteAction" type="com.cloudera.cdk.data.hbase.DeleteAction"/>
      <doc>
      <![CDATA[Execute a Delete on HBase.
 
 Any DeleteActionModifers registered with registerDeleteModifier will be
 invoked before the Delete is executed.
 
 @param deleteAction
          The delete to execute on HBase.
 @return True if the delete succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deleteAction" type="com.cloudera.cdk.data.hbase.DeleteAction"/>
      <param name="deleteActionModifier" type="com.cloudera.cdk.data.hbase.DeleteActionModifier"/>
      <doc>
      <![CDATA[Execute the delete on HBase, invoking the deleteModifier before executing
 the delete if deleteModifier is not null.
 
 Any DeleteActionModifers registered with registerDeleteModifier will be
 invoked after the deleteActionModifier passed to this method is invoked,
 and before the Delete is executed.
 
 @param deleteAction
          The Delete to execute.
 @param deleteActionModifier
          Invoked before the Delete to give callers a chance to modify the
          Delete before it is executed.
 @return True if the delete succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="columns" type="java.util.Set&lt;java.lang.String&gt;"/>
      <param name="checkAction" type="com.cloudera.cdk.data.hbase.VersionCheckAction"/>
      <param name="keySerDe" type="com.cloudera.cdk.data.hbase.KeySerDe&lt;K&gt;"/>
      <doc>
      <![CDATA[Execute a Delete on HBase, creating the Delete from the key, and the set of
 columns. Only the columns specified in this set will be deleted in the row.
 
 Any DeleteActionModifers registered with registerDeleteModifier will be
 invoked before the Delete is executed.
 
 @param key
          The Key to map to a Put with the entityMapper.
 @param columns
          The set of columns to delete from the row.
 @param checkAction
          A VersionCheckAction that will force this delete to do a
          checkAndDelete against a version count in the row
 @return True if the delete succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="columns" type="java.util.Set&lt;java.lang.String&gt;"/>
      <param name="checkAction" type="com.cloudera.cdk.data.hbase.VersionCheckAction"/>
      <param name="deleteActionModifier" type="com.cloudera.cdk.data.hbase.DeleteActionModifier"/>
      <param name="keySerDe" type="com.cloudera.cdk.data.hbase.KeySerDe&lt;K&gt;"/>
      <doc>
      <![CDATA[Execute a Delete on HBase, creating the Delete from the key, and the set of
 columns. Only the columns specified in this set will be deleted in the row.
 deleteModifier will be invoked on this created Delete before the Delete is
 executed.
 
 Any DeleteActionModifers registered with registerDeleteActionModifier will
 be invoked after the deleteActionModifier passed to this method is invoked,
 and before the Delete is executed.
 
 @param key
          The Key to map to a Put with the entityMapper.
 @param columns
          The set of columns to delete from the row.
 @param checkAction
          A VersionCheckAction that will force this delete to do a
          checkAndDelete against a version count in the row
 @param deleteActionModifier
          Invoked before the Delete to give callers a chance to modify the
          Delete before it is executed.
 @return True if the delete succeeded, False if the put failed due to update
         conflict]]>
      </doc>
    </method>
    <method name="getScannerBuilder" return="com.cloudera.cdk.data.hbase.EntityScannerBuilder&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entityMapper" type="com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"/>
      <doc>
      <![CDATA[Refactored the key subsystem by removing the "Key" wrapper type, Get an
 EntityScannerBuilder that the client can use to build an EntityScanner.
 
 @param entityMapper
          The EntityMapper to use to map rows to entities.
 @return The EntityScannerBuilder]]>
      </doc>
    </method>
    <method name="createBatch" return="com.cloudera.cdk.data.dao.EntityBatch&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entityMapper" type="com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"/>
      <param name="writeBufferSize" type="long"/>
    </method>
    <method name="createBatch" return="com.cloudera.cdk.data.dao.EntityBatch&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entityMapper" type="com.cloudera.cdk.data.hbase.EntityMapper&lt;K, E&gt;"/>
    </method>
    <doc>
    <![CDATA[This class simplifies the use of HBase client, and helps to avoid common
 errors by managing its own cleanup of resources.
 
 This class uses the Template Method pattern to allow users to implement
 callbacks for things like entity mapping, and get and put modification
 (modify Get and Put before sending them off to HBase).]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.HBaseClientTemplate -->
  <!-- start class com.cloudera.cdk.data.hbase.HBaseUtils -->
  <class name="HBaseUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HBaseUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="mergePuts" return="org.apache.hadoop.hbase.client.Put"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyBytes" type="byte[]"/>
      <param name="putList" type="java.util.List&lt;org.apache.hadoop.hbase.client.Put&gt;"/>
      <doc>
      <![CDATA[Given a list of puts, create a new put with the values in each put merged
 together. It is expected that no puts have a value for the same fully
 qualified column. Return the new put.
 
 @param key
          The key of the new put.
 @param putList
          The list of puts to merge
 @return the new Put instance]]>
      </doc>
    </method>
    <method name="mergePutActions" return="com.cloudera.cdk.data.hbase.PutAction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyBytes" type="byte[]"/>
      <param name="putActionList" type="java.util.List&lt;com.cloudera.cdk.data.hbase.PutAction&gt;"/>
      <doc>
      <![CDATA[Given a list of PutActions, create a new PutAction with the values in each
 put merged together. It is expected that no puts have a value for the same
 fully qualified column. Return the new PutAction.
 
 @param key
          The key of the new put.
 @param putActionList
          The list of PutActions to merge
 @return the new PutAction instance]]>
      </doc>
    </method>
    <method name="addToPut"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="put1" type="org.apache.hadoop.hbase.client.Put"/>
      <param name="put2" type="org.apache.hadoop.hbase.client.Put"/>
      <doc>
      <![CDATA[For each value in put2, add it to put1.
 
 @param put1
          The put to modify
 @param put2
          The put to add to put1]]>
      </doc>
    </method>
    <method name="addColumnsToScan"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columns" type="java.util.Collection&lt;java.lang.String&gt;"/>
      <param name="scan" type="org.apache.hadoop.hbase.client.Scan"/>
      <doc>
      <![CDATA[Add a Collection of Columns to a Scanner, Only Add Single Columns
 If Their Family Isn't Already Being Added.
 @param columns
          Collection of columns to add to the scan
 @param scan
          The scanner object to add the columns to]]>
      </doc>
    </method>
    <method name="addColumnsToGet"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columns" type="java.util.Collection&lt;java.lang.String&gt;"/>
      <param name="get" type="org.apache.hadoop.hbase.client.Get"/>
      <doc>
      <![CDATA[Add a Collection of Columns to a Get, Only Add Single Columns
 If Their Family Isn't Already Being Added.
 @param columns
          Collection of columns to add to the Get
 @param get
          The Get object to add the columns to]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility functions for working with the HBase API.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.HBaseUtils -->
  <!-- start interface com.cloudera.cdk.data.hbase.KeyEntitySchemaParser -->
  <interface name="KeyEntitySchemaParser"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="parseEntity" return="ENTITY_SCHEMA extends com.cloudera.cdk.data.dao.EntitySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="java.lang.String"/>
      <doc>
      <![CDATA[Parse the raw entity schema.
 
 @param schema
          The raw entity schema
 @return The parsed schema]]>
      </doc>
    </method>
    <method name="parseKey" return="KEY_SCHEMA extends com.cloudera.cdk.data.dao.KeySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="java.lang.String"/>
      <doc>
      <![CDATA[Parse the raw key schema
 
 @param schema
          The raw key schema
 @return The parsed schema]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for the HBase Common Key and Entity parser.

 @param <KEY_SCHEMA>
          The type that the key schema gets parsed to. Extends
          KeySchema<RAW_SCHEMA>
 @param <ENTITY_SCHEMA>
          The type that the raw entity schema gets parsed to. Extends
          EntitySchema<RAW_SCHEMA>]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.KeyEntitySchemaParser -->
  <!-- start interface com.cloudera.cdk.data.hbase.KeySerDe -->
  <interface name="KeySerDe"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="serialize" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Serialize the key to bytes.
 
 @param key
          The key to serialize
 @return The byte array]]>
      </doc>
    </method>
    <method name="serializePartial" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="partialKey" type="com.cloudera.cdk.data.dao.PartialKey&lt;K&gt;"/>
      <doc>
      <![CDATA[Serialize a partial key to bytes.
 
 @param partialKey
          The partial key to serialize
 @return The byte array]]>
      </doc>
    </method>
    <method name="deserialize" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyBytes" type="byte[]"/>
      <doc>
      <![CDATA[Deserialize the key from a byte array.
 
 @param keyBytes
          The byte array to deserialize the key from.
 @return The key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class handles key serialization and deserialization.
 
 @param <K>
          The type of the key]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.KeySerDe -->
  <!-- start class com.cloudera.cdk.data.hbase.PutAction -->
  <class name="PutAction" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PutAction" type="org.apache.hadoop.hbase.client.Put"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PutAction" type="org.apache.hadoop.hbase.client.Put, com.cloudera.cdk.data.hbase.VersionCheckAction"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPut" return="org.apache.hadoop.hbase.client.Put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVersionCheckAction" return="com.cloudera.cdk.data.hbase.VersionCheckAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setVersionCheckAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionCheckAction" type="com.cloudera.cdk.data.hbase.VersionCheckAction"/>
    </method>
    <doc>
    <![CDATA[Represents an HBase Put. This simple class encapsulates both a Put, and a
 VersionCheckAction operation, which allows us to do checkAndPut.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.PutAction -->
  <!-- start interface com.cloudera.cdk.data.hbase.PutActionModifier -->
  <interface name="PutActionModifier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="modifyPutAction" return="com.cloudera.cdk.data.hbase.PutAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="putAction" type="com.cloudera.cdk.data.hbase.PutAction"/>
      <doc>
      <![CDATA[Modify the PutAction instance.
 
 @param putAction
          The PutAction instance to modify.
 @return The modified PutAction]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Generic callback interface used by HBaseClientTemplate class. This interface
 modifies a Put instance before the HBaseClientTemplate executes it on the
 HBase table.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.PutActionModifier -->
  <!-- start interface com.cloudera.cdk.data.hbase.ScanModifier -->
  <interface name="ScanModifier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="modifyScan" return="org.apache.hadoop.hbase.client.Scan"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scan" type="org.apache.hadoop.hbase.client.Scan"/>
      <doc>
      <![CDATA[Modify the Scan instance.
 
 @param scan
          The Scan instance to modify
 @return The modified Scan instance]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Generic callback interface used by HBaseClientTemplate class. This interface
 modifies a Scan instance before the HBaseClientTemplate executes it on the
 HBase table.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.ScanModifier -->
  <!-- start class com.cloudera.cdk.data.hbase.VersionCheckAction -->
  <class name="VersionCheckAction" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VersionCheckAction" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getVersion" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A version check action, which allows us to check that the
 version of an entity hasn't changed. This is useful for
 optimistic concurrency control (OCC).]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.VersionCheckAction -->
</package>
<package name="com.cloudera.cdk.data.hbase.avro">
  <!-- start class com.cloudera.cdk.data.hbase.avro.GenericAvroDao -->
  <class name="GenericAvroDao" extends="com.cloudera.cdk.data.hbase.BaseDao&lt;org.apache.avro.generic.GenericRecord, org.apache.avro.generic.GenericRecord&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GenericAvroDao" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a GenericAvroDao.
 
 @param tablePool
          An HTablePool instance to use for connecting to HBase.
 @param tableName
          The name of the table this Dao will read from and write to in
          HBase.
 @param keySchemaStr
          The Avro schema that represents the Key structure for row keys in
          this table.
 @param entitySchemaString
          The json string representing the special avro record schema, that
          contains metadata in annotations of the Avro record fields. See
          {@link AvroEntityMapper} for details.]]>
      </doc>
    </constructor>
    <constructor name="GenericAvroDao" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, java.lang.String, java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a GenericAvroDao.
 
 @param tablePool
          An HTablePool instance to use for connecting to HBase.
 @param tableName
          The name of the table this Dao will read from and write to in
          HBase.
 @param keySchemaStr
          The Avro schema that represents the Key structure for row keys in
          this table.
 @param entitySchemaStream
          The InputStream that contains a json string representing the
          special avro record schema, that contains metadata in annotations
          of the Avro record fields. See {@link AvroEntityMapper} for
          details.]]>
      </doc>
    </constructor>
    <constructor name="GenericAvroDao" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, java.lang.String, com.cloudera.cdk.data.dao.SchemaManager, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the GenericAvroDao with an EntityManager, which will provide the
 entity mapper to this Dao that knows how to map the different entity schema
 versions defined by the managed schema. The entitySchemaString parameter
 represents the schema to use for writes.
 
 @param tablePool
          An HTabePool instance to use for connecting to HBase.
 @param tableName
          The table name of the managed schema.
 @param entityName
          The entity name of the managed schema.
 @param schemaManager
          The EntityManager which will create the entity mapper that will
          power this dao.
 @param entitySchemaString
          The schema as a string representing the schema version that this
          DAO should use for writes.]]>
      </doc>
    </constructor>
    <constructor name="GenericAvroDao" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, java.lang.String, com.cloudera.cdk.data.dao.SchemaManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the GenericAvroDao with an EntityManager, which will provide the
 entity mapper to this Dao that knows how to map the different entity schema
 versions defined by the managed schema. The newest schema version available
 at the time of this dao's creation will be used for writes.
 
 @param tablePool
          An HTabePool instance to use for connecting to HBase.
 @param tableName
          The table name of the managed schema.
 @param entityName
          The entity name of the managed schema.
 @param schemaManager
          The SchemaManager which will create the entity mapper that will
          power this dao.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A Dao for Avro's GenericRecords. In this Dao implementation, both the
 underlying key record type, and the entity type are GenericRecords. This Dao
 allows us to persist and fetch these GenericRecords to and from HBase.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.GenericAvroDao -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.SpecificAvroDao -->
  <class name="SpecificAvroDao" extends="com.cloudera.cdk.data.hbase.BaseDao&lt;K, E&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SpecificAvroDao" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, java.lang.String, java.lang.String, java.lang.Class&lt;K&gt;, java.lang.Class&lt;E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the SpecificAvroDao.
 
 @param tablePool
          An HTablePool instance to use for connecting to HBase.
 @param tableName
          The name of the table this Dao will read from and write to.
 @param keySchemaString
          The Avro schema string that represents the Key structure for row
          keys in this table.
 @param entitySchemaString
          The json string representing the special avro record schema, that
          contains metadata in annotations of the Avro record fields. See
          {@link AvroEntityMapper} for details.
 @param keyClass
          The class of the SpecificRecord this DAO will use as a key
 @param entityClass
          The class of the SpecificRecord this DAO will persist and fetch.]]>
      </doc>
    </constructor>
    <constructor name="SpecificAvroDao" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, java.io.InputStream, java.io.InputStream, java.lang.Class&lt;K&gt;, java.lang.Class&lt;E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the SpecificAvroDao.
 
 @param tablePool
          An HTablePool instance to use for connecting to HBase.
 @param tableName
          The name of the table this Dao will read from and write to.
 @param keySchemaStream
          The json stream representing the avro schema for the key.
 @param entitySchemaStream
          The json stream representing the special avro record schema, that
          contains metadata in annotations of the Avro record fields. See
          {@link AvroEntityMapper} for details.
 @param keyClass
          The class of the SpecificRecord this DAO will use as a key
 @param entityClass
          The class of the SpecificRecord this DAO will persist and fetch.]]>
      </doc>
    </constructor>
    <constructor name="SpecificAvroDao" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String, java.lang.String, com.cloudera.cdk.data.dao.SchemaManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the SpecificAvroDao with an EntityManager, which will provide the
 entity mapper to this Dao that knows how to map the different entity schema
 versions defined by the managed schema.
 
 @param tablePool
          An HTabePool instance to use for connecting to HBase.
 @param tableName
          The table name of the managed schema.
 @param entityName
          The entity name of the managed schema.
 @param schemaManager
          The SchemaManager which will be used to query schema information
          from the meta store.]]>
      </doc>
    </constructor>
    <method name="buildCompositeDao" return="com.cloudera.cdk.data.dao.Dao&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tablePool" type="org.apache.hadoop.hbase.client.HTablePool"/>
      <param name="tableName" type="java.lang.String"/>
      <param name="keySchemaString" type="java.lang.String"/>
      <param name="subEntitySchemaStrings" type="java.util.List&lt;java.lang.String&gt;"/>
      <param name="keyClass" type="java.lang.Class&lt;K&gt;"/>
      <param name="entityClass" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Create a CompositeDao, which will return SpecificRecord instances
 represented by the entitySchemaString avro schema. This avro schema must be
 a composition of the schemas in the subEntitySchemaStrings list.
 
 @param tablePool
          An HTablePool instance to use for connecting to HBase
 @param tableName
          The table name this dao will read from and write to
 @param keySchemaString
          The Avro schema string that represents the Key structure for row
          keys in this table.
 @param subEntitySchemaStrings
          The list of entities that make up the composite. This list must be
          in the same order as the fields defined in the entitySchemaString.
 @param keyClass
          The class of the SpecificRecord representing the Key of rows this
          dao will fetch.
 @param entityClass
          The class of the SpecificRecord this DAO will persist and fetch.
 @return The CompositeDao instance.
 @throws SchemaNotFoundException
 @throws SchemaValidationException]]>
      </doc>
    </method>
    <method name="buildCompositeDaoWithInputStream" return="com.cloudera.cdk.data.dao.Dao&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tablePool" type="org.apache.hadoop.hbase.client.HTablePool"/>
      <param name="tableName" type="java.lang.String"/>
      <param name="keySchemaStream" type="java.io.InputStream"/>
      <param name="subEntitySchemaStreams" type="java.util.List&lt;java.io.InputStream&gt;"/>
      <param name="keyClass" type="java.lang.Class&lt;K&gt;"/>
      <param name="entityClass" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Create a CompositeDao, which will return SpecificRecord instances
 represented by the entitySchemaString avro schema. This avro schema must be
 a composition of the schemas in the subEntitySchemaStrings list.
 
 @param tablePool
          An HTablePool instance to use for connecting to HBase
 @param tableName
          The table name this dao will read from and write to
 @param keySchemaStream
          The Avro schema input stream that represents the Key structure for
          row keys in this table.
 @param subEntitySchemaStreams
          The list of entities that make up the composite. This list must be
          in the same order as the fields defined in the entitySchemaString.
 @param keyClass
          The class of the SpecificRecord representing the Key of rows this
          dao will fetch.
 @param entityClass
          The class of the SpecificRecord this DAO will persist and fetch.
 @return The CompositeDao instance.
 @throws SchemaNotFoundException
 @throws SchemaValidationException]]>
      </doc>
    </method>
    <method name="buildCompositeDaoWithEntityManager" return="com.cloudera.cdk.data.dao.Dao&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tablePool" type="org.apache.hadoop.hbase.client.HTablePool"/>
      <param name="tableName" type="java.lang.String"/>
      <param name="entityClass" type="java.lang.Class&lt;E&gt;"/>
      <param name="schemaManager" type="com.cloudera.cdk.data.dao.SchemaManager"/>
      <doc>
      <![CDATA[Create a CompositeDao, which will return SpecificRecord instances
 represented by the entitySchemaString avro schema. This avro schema must be
 a composition of the schemas in the subEntitySchemaStrings list.
 
 @param tablePool
          An HTabePool instance to use for connecting to HBase.
 @param tableName
          The table name of the managed schema.
 @param entityClass
          The class that is the composite record, which is made up of fields
          referencing the sub records.
 @param schemaManager
          The SchemaManager which will use to create the entity mapper that will
          power this dao.
 @return The CompositeDao instance.
 @throws SchemaNotFoundException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Dao for Avro's SpecificRecords. In this Dao implementation, both the
 underlying key record type, and the entity type are SpecificRecords. This Dao
 allows us to persist and fetch these SpecificRecords to and from HBase.
 
 @param <K>
          The Key's underlying record type.
 @param <E>
          The entity type.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.SpecificAvroDao -->
</package>
<package name="com.cloudera.cdk.data.hbase.avro.entities">
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord -->
  <class name="ArrayRecord" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="ArrayRecord"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use {@link \#newBuilder()}.]]>
      </doc>
    </constructor>
    <constructor name="ArrayRecord" type="java.lang.String, java.lang.Long, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getSubfield1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subfield1' field.]]>
      </doc>
    </method>
    <method name="getSubfield2" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subfield2' field.]]>
      </doc>
    </method>
    <method name="getSubfield3" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subfield3' field.]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new ArrayRecord RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder"/>
      <doc>
      <![CDATA[Creates a new ArrayRecord RecordBuilder by copying an existing Builder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord"/>
      <doc>
      <![CDATA[Creates a new ArrayRecord RecordBuilder by copying an existing ArrayRecord instance]]>
      </doc>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder -->
  <class name="ArrayRecord.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase&lt;com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder&lt;com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord&gt;"/>
    <method name="getSubfield1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subfield1' field]]>
      </doc>
    </method>
    <method name="setSubfield1" return="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'subfield1' field]]>
      </doc>
    </method>
    <method name="hasSubfield1" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'subfield1' field has been set]]>
      </doc>
    </method>
    <method name="clearSubfield1" return="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'subfield1' field]]>
      </doc>
    </method>
    <method name="getSubfield2" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subfield2' field]]>
      </doc>
    </method>
    <method name="setSubfield2" return="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Sets the value of the 'subfield2' field]]>
      </doc>
    </method>
    <method name="hasSubfield2" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'subfield2' field has been set]]>
      </doc>
    </method>
    <method name="clearSubfield2" return="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'subfield2' field]]>
      </doc>
    </method>
    <method name="getSubfield3" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subfield3' field]]>
      </doc>
    </method>
    <method name="setSubfield3" return="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'subfield3' field]]>
      </doc>
    </method>
    <method name="hasSubfield3" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'subfield3' field has been set]]>
      </doc>
    </method>
    <method name="clearSubfield3" return="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'subfield3' field]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for ArrayRecord instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord.Builder -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord -->
  <class name="CompositeRecord" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="CompositeRecord"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use {@link \#newBuilder()}.]]>
      </doc>
    </constructor>
    <constructor name="CompositeRecord" type="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1, com.cloudera.cdk.data.hbase.avro.entities.SubRecord2"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getSubRecord1" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subRecord1' field.]]>
      </doc>
    </method>
    <method name="getSubRecord2" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subRecord2' field.]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new CompositeRecord RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord.Builder"/>
      <doc>
      <![CDATA[Creates a new CompositeRecord RecordBuilder by copying an existing Builder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord"/>
      <doc>
      <![CDATA[Creates a new CompositeRecord RecordBuilder by copying an existing CompositeRecord instance]]>
      </doc>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord.Builder -->
  <class name="CompositeRecord.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase&lt;com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder&lt;com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord&gt;"/>
    <method name="getSubRecord1" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subRecord1' field]]>
      </doc>
    </method>
    <method name="setSubRecord1" return="com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1"/>
      <doc>
      <![CDATA[Sets the value of the 'subRecord1' field]]>
      </doc>
    </method>
    <method name="hasSubRecord1" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'subRecord1' field has been set]]>
      </doc>
    </method>
    <method name="clearSubRecord1" return="com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'subRecord1' field]]>
      </doc>
    </method>
    <method name="getSubRecord2" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subRecord2' field]]>
      </doc>
    </method>
    <method name="setSubRecord2" return="com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2"/>
      <doc>
      <![CDATA[Sets the value of the 'subRecord2' field]]>
      </doc>
    </method>
    <method name="hasSubRecord2" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'subRecord2' field has been set]]>
      </doc>
    </method>
    <method name="clearSubRecord2" return="com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'subRecord2' field]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for CompositeRecord instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.CompositeRecord.Builder -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord -->
  <class name="EmbeddedRecord" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="EmbeddedRecord"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use {@link \#newBuilder()}.]]>
      </doc>
    </constructor>
    <constructor name="EmbeddedRecord" type="java.lang.String, java.lang.Long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getEmbeddedField1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'embeddedField1' field.]]>
      </doc>
    </method>
    <method name="getEmbeddedField2" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'embeddedField2' field.]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new EmbeddedRecord RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord.Builder"/>
      <doc>
      <![CDATA[Creates a new EmbeddedRecord RecordBuilder by copying an existing Builder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord"/>
      <doc>
      <![CDATA[Creates a new EmbeddedRecord RecordBuilder by copying an existing EmbeddedRecord instance]]>
      </doc>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord.Builder -->
  <class name="EmbeddedRecord.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase&lt;com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder&lt;com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord&gt;"/>
    <method name="getEmbeddedField1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'embeddedField1' field]]>
      </doc>
    </method>
    <method name="setEmbeddedField1" return="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'embeddedField1' field]]>
      </doc>
    </method>
    <method name="hasEmbeddedField1" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'embeddedField1' field has been set]]>
      </doc>
    </method>
    <method name="clearEmbeddedField1" return="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'embeddedField1' field]]>
      </doc>
    </method>
    <method name="getEmbeddedField2" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'embeddedField2' field]]>
      </doc>
    </method>
    <method name="setEmbeddedField2" return="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Sets the value of the 'embeddedField2' field]]>
      </doc>
    </method>
    <method name="hasEmbeddedField2" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'embeddedField2' field has been set]]>
      </doc>
    </method>
    <method name="clearEmbeddedField2" return="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'embeddedField2' field]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for EmbeddedRecord instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord.Builder -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.SubRecord1 -->
  <class name="SubRecord1" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="SubRecord1"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use {@link \#newBuilder()}.]]>
      </doc>
    </constructor>
    <constructor name="SubRecord1" type="java.lang.String, java.lang.String, java.lang.Long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getField1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field1' field.]]>
      </doc>
    </method>
    <method name="getField2" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field2' field.]]>
      </doc>
    </method>
    <method name="getVersion" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'version' field.]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new SubRecord1 RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder"/>
      <doc>
      <![CDATA[Creates a new SubRecord1 RecordBuilder by copying an existing Builder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1"/>
      <doc>
      <![CDATA[Creates a new SubRecord1 RecordBuilder by copying an existing SubRecord1 instance]]>
      </doc>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.SubRecord1 -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder -->
  <class name="SubRecord1.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase&lt;com.cloudera.cdk.data.hbase.avro.entities.SubRecord1&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder&lt;com.cloudera.cdk.data.hbase.avro.entities.SubRecord1&gt;"/>
    <method name="getField1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field1' field]]>
      </doc>
    </method>
    <method name="setField1" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'field1' field]]>
      </doc>
    </method>
    <method name="hasField1" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'field1' field has been set]]>
      </doc>
    </method>
    <method name="clearField1" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'field1' field]]>
      </doc>
    </method>
    <method name="getField2" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field2' field]]>
      </doc>
    </method>
    <method name="setField2" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'field2' field]]>
      </doc>
    </method>
    <method name="hasField2" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'field2' field has been set]]>
      </doc>
    </method>
    <method name="clearField2" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'field2' field]]>
      </doc>
    </method>
    <method name="getVersion" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'version' field]]>
      </doc>
    </method>
    <method name="setVersion" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Sets the value of the 'version' field]]>
      </doc>
    </method>
    <method name="hasVersion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'version' field has been set]]>
      </doc>
    </method>
    <method name="clearVersion" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'version' field]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord1"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for SubRecord1 instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.SubRecord1.Builder -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.SubRecord2 -->
  <class name="SubRecord2" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="SubRecord2"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use {@link \#newBuilder()}.]]>
      </doc>
    </constructor>
    <constructor name="SubRecord2" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getField1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field1' field.]]>
      </doc>
    </method>
    <method name="getField2" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field2' field.]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new SubRecord2 RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2.Builder"/>
      <doc>
      <![CDATA[Creates a new SubRecord2 RecordBuilder by copying an existing Builder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2"/>
      <doc>
      <![CDATA[Creates a new SubRecord2 RecordBuilder by copying an existing SubRecord2 instance]]>
      </doc>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.SubRecord2 -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.SubRecord2.Builder -->
  <class name="SubRecord2.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase&lt;com.cloudera.cdk.data.hbase.avro.entities.SubRecord2&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder&lt;com.cloudera.cdk.data.hbase.avro.entities.SubRecord2&gt;"/>
    <method name="getField1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field1' field]]>
      </doc>
    </method>
    <method name="setField1" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'field1' field]]>
      </doc>
    </method>
    <method name="hasField1" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'field1' field has been set]]>
      </doc>
    </method>
    <method name="clearField1" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'field1' field]]>
      </doc>
    </method>
    <method name="getField2" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field2' field]]>
      </doc>
    </method>
    <method name="setField2" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'field2' field]]>
      </doc>
    </method>
    <method name="hasField2" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'field2' field has been set]]>
      </doc>
    </method>
    <method name="clearField2" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'field2' field]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.hbase.avro.entities.SubRecord2"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for SubRecord2 instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.SubRecord2.Builder -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.TestEnum -->
  <class name="TestEnum" extends="java.lang.Enum&lt;com.cloudera.cdk.data.hbase.avro.entities.TestEnum&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.cloudera.cdk.data.hbase.avro.entities.TestEnum[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.cloudera.cdk.data.hbase.avro.entities.TestEnum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.TestEnum -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.TestKey -->
  <class name="TestKey" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="TestKey"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use {@link \#newBuilder()}.]]>
      </doc>
    </constructor>
    <constructor name="TestKey" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getPart1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'part1' field.]]>
      </doc>
    </method>
    <method name="getPart2" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'part2' field.]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.TestKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new TestKey RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.TestKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.TestKey.Builder"/>
      <doc>
      <![CDATA[Creates a new TestKey RecordBuilder by copying an existing Builder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.TestKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.TestKey"/>
      <doc>
      <![CDATA[Creates a new TestKey RecordBuilder by copying an existing TestKey instance]]>
      </doc>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.TestKey -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.TestKey.Builder -->
  <class name="TestKey.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase&lt;com.cloudera.cdk.data.hbase.avro.entities.TestKey&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder&lt;com.cloudera.cdk.data.hbase.avro.entities.TestKey&gt;"/>
    <method name="getPart1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'part1' field]]>
      </doc>
    </method>
    <method name="setPart1" return="com.cloudera.cdk.data.hbase.avro.entities.TestKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'part1' field]]>
      </doc>
    </method>
    <method name="hasPart1" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'part1' field has been set]]>
      </doc>
    </method>
    <method name="clearPart1" return="com.cloudera.cdk.data.hbase.avro.entities.TestKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'part1' field]]>
      </doc>
    </method>
    <method name="getPart2" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'part2' field]]>
      </doc>
    </method>
    <method name="setPart2" return="com.cloudera.cdk.data.hbase.avro.entities.TestKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'part2' field]]>
      </doc>
    </method>
    <method name="hasPart2" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'part2' field has been set]]>
      </doc>
    </method>
    <method name="clearPart2" return="com.cloudera.cdk.data.hbase.avro.entities.TestKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'part2' field]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.hbase.avro.entities.TestKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for TestKey instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.TestKey.Builder -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.TestRecord -->
  <class name="TestRecord" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="TestRecord"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use {@link \#newBuilder()}.]]>
      </doc>
    </constructor>
    <constructor name="TestRecord" type="java.lang.String, java.lang.String, com.cloudera.cdk.data.hbase.avro.entities.TestEnum, java.util.Map&lt;java.lang.String, java.lang.String&gt;, com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord, java.util.List&lt;com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord&gt;, java.lang.Long, java.lang.Long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getField1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field1' field.]]>
      </doc>
    </method>
    <method name="getField2" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field2' field.]]>
      </doc>
    </method>
    <method name="getEnum$" return="com.cloudera.cdk.data.hbase.avro.entities.TestEnum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'enum$' field.]]>
      </doc>
    </method>
    <method name="getField3" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field3' field.]]>
      </doc>
    </method>
    <method name="getField4" return="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field4' field.]]>
      </doc>
    </method>
    <method name="getField5" return="java.util.List&lt;com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field5' field.]]>
      </doc>
    </method>
    <method name="getIncrement" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'increment' field.]]>
      </doc>
    </method>
    <method name="getVersion" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'version' field.]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new TestRecord RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"/>
      <doc>
      <![CDATA[Creates a new TestRecord RecordBuilder by copying an existing Builder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.avro.entities.TestRecord"/>
      <doc>
      <![CDATA[Creates a new TestRecord RecordBuilder by copying an existing TestRecord instance]]>
      </doc>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.TestRecord -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder -->
  <class name="TestRecord.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase&lt;com.cloudera.cdk.data.hbase.avro.entities.TestRecord&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder&lt;com.cloudera.cdk.data.hbase.avro.entities.TestRecord&gt;"/>
    <method name="getField1" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field1' field]]>
      </doc>
    </method>
    <method name="setField1" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'field1' field]]>
      </doc>
    </method>
    <method name="hasField1" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'field1' field has been set]]>
      </doc>
    </method>
    <method name="clearField1" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'field1' field]]>
      </doc>
    </method>
    <method name="getField2" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field2' field]]>
      </doc>
    </method>
    <method name="setField2" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'field2' field]]>
      </doc>
    </method>
    <method name="hasField2" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'field2' field has been set]]>
      </doc>
    </method>
    <method name="clearField2" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'field2' field]]>
      </doc>
    </method>
    <method name="getEnum$" return="com.cloudera.cdk.data.hbase.avro.entities.TestEnum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'enum$' field]]>
      </doc>
    </method>
    <method name="setEnum$" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="com.cloudera.cdk.data.hbase.avro.entities.TestEnum"/>
      <doc>
      <![CDATA[Sets the value of the 'enum$' field]]>
      </doc>
    </method>
    <method name="hasEnum$" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'enum$' field has been set]]>
      </doc>
    </method>
    <method name="clearEnum$" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'enum$' field]]>
      </doc>
    </method>
    <method name="getField3" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field3' field]]>
      </doc>
    </method>
    <method name="setField3" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Sets the value of the 'field3' field]]>
      </doc>
    </method>
    <method name="hasField3" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'field3' field has been set]]>
      </doc>
    </method>
    <method name="clearField3" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'field3' field]]>
      </doc>
    </method>
    <method name="getField4" return="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field4' field]]>
      </doc>
    </method>
    <method name="setField4" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="com.cloudera.cdk.data.hbase.avro.entities.EmbeddedRecord"/>
      <doc>
      <![CDATA[Sets the value of the 'field4' field]]>
      </doc>
    </method>
    <method name="hasField4" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'field4' field has been set]]>
      </doc>
    </method>
    <method name="clearField4" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'field4' field]]>
      </doc>
    </method>
    <method name="getField5" return="java.util.List&lt;com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'field5' field]]>
      </doc>
    </method>
    <method name="setField5" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.List&lt;com.cloudera.cdk.data.hbase.avro.entities.ArrayRecord&gt;"/>
      <doc>
      <![CDATA[Sets the value of the 'field5' field]]>
      </doc>
    </method>
    <method name="hasField5" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'field5' field has been set]]>
      </doc>
    </method>
    <method name="clearField5" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'field5' field]]>
      </doc>
    </method>
    <method name="getIncrement" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'increment' field]]>
      </doc>
    </method>
    <method name="setIncrement" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Sets the value of the 'increment' field]]>
      </doc>
    </method>
    <method name="hasIncrement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'increment' field has been set]]>
      </doc>
    </method>
    <method name="clearIncrement" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'increment' field]]>
      </doc>
    </method>
    <method name="getVersion" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'version' field]]>
      </doc>
    </method>
    <method name="setVersion" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Sets the value of the 'version' field]]>
      </doc>
    </method>
    <method name="hasVersion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'version' field has been set]]>
      </doc>
    </method>
    <method name="clearVersion" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'version' field]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.hbase.avro.entities.TestRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for TestRecord instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.entities.TestRecord.Builder -->
</package>
<package name="com.cloudera.cdk.data.hbase.avro.entities.protocol">
  <!-- start interface com.cloudera.cdk.data.hbase.avro.entities.protocol.CompositeRecordProtocol -->
  <interface name="CompositeRecordProtocol"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="PROTOCOL" type="org.apache.avro.Protocol"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.avro.entities.protocol.CompositeRecordProtocol -->
  <!-- start interface com.cloudera.cdk.data.hbase.avro.entities.protocol.CompositeRecordProtocol.Callback -->
  <interface name="CompositeRecordProtocol.Callback"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.hbase.avro.entities.protocol.CompositeRecordProtocol"/>
    <field name="PROTOCOL" type="org.apache.avro.Protocol"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.avro.entities.protocol.CompositeRecordProtocol.Callback -->
</package>
<package name="com.cloudera.cdk.data.hbase.avro.io">
  <!-- start class com.cloudera.cdk.data.hbase.avro.io.ColumnDecoder -->
  <class name="ColumnDecoder" extends="org.apache.avro.io.Decoder"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ColumnDecoder" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readNull"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="org.apache.avro.util.Utf8"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="old" type="org.apache.avro.util.Utf8"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBytes" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="old" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFixed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipFixed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readEnum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readArrayStart" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="arrayNext" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipArray" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readMapStart" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mapNext" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipMap" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An Avro Decoder implementation used for decoding Avro instances from HBase
 columns. This is basically an Avro BinaryDecoder with custom encoding of int,
 long, and String types.
 
 int and long are serialized in standard 4 and 8 byte format (instead of
 Avro's ZigZag encoding) so that we can use HBase's atomic increment
 functionality on columns.
 
 Strings are encoding as UTF-8 bytes. This is for backward compatibility
 reasons, and is something we want to change in the future.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.io.ColumnDecoder -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.io.ColumnEncoder -->
  <class name="ColumnEncoder" extends="org.apache.avro.io.Encoder"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ColumnEncoder" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ColumnEncoder" type="java.io.OutputStream, com.cloudera.cdk.data.hbase.avro.io.ColumnEncoder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNull"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="org.apache.avro.util.Utf8"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFixed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeEnum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeArrayStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setItemCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemCount" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeArrayEnd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeMapStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeMapEnd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeIndex"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unionIndex" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.io.ColumnEncoder -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.io.MemcmpDecoder -->
  <class name="MemcmpDecoder" extends="org.apache.avro.io.Decoder"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MemcmpDecoder" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readNull"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A boolean is decoded where a byte value of 1 is true, and 0 is false.
 
 @return The decoded boolean.]]>
      </doc>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A int was written by flipping the sign bit, and writing it as a big endian
 int.
 
 To decode, we do the reverse, flipping the sign bit, and reading the int
 from the bytes.
 
 @return The decoded int.]]>
      </doc>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A long was written by flipping the sign bit, and writing it as a big endian
 long.
 
 To decode, we do the reverse, flipping the sign bit, and reading the long
 from the bytes.
 
 @return The decoded long.]]>
      </doc>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A float was written as 4 bytes. It was encoded as a 32 bit integer. If it
 was a negative number, the complement of the 31 bits (every bit except the
 sign bit) was taken.
 
 To decode, we read the 4 byte integer. If the most significant bit is 1, we
 take the compliment of the lower 31 bits. Finally we convert this integer
 to float using Float.intBitsToFloat.
 
 @return The decoded float.]]>
      </doc>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A double was written as 8 bytes. It was encoded as a 64 bit long. If it was
 a negative number, the complement of the 63 bits (every bit except the sign
 bit) was taken.
 
 To decode, we read the 8 byte long. If the most significant bit is 1, we
 take the compliment of the lower 63 bits. Finally we convert this double to
 long using Double.longBitsToDouble.
 
 @return The decoded double.]]>
      </doc>
    </method>
    <method name="readString" return="org.apache.avro.util.Utf8"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="old" type="org.apache.avro.util.Utf8"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A string is decoded by reading the string as bytes using the readBytes
 function.
 
 @return The decoded String.]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[To skip a string, we have to read it since the memcmp encoder doesn't
 length prefix the string.]]>
      </doc>
    </method>
    <method name="readBytes" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="old" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Bytes are decoded by reading each byte until we find two consecutive 0
 bytes. A 0 byte followed by a 1 byte is translated into a 0 byte.
 
 @return the decoded byte buffer.]]>
      </doc>
    </method>
    <method name="skipBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[To skip bytes, we have to read the bytes, since we aren't length prefixing
 the byte array.]]>
      </doc>
    </method>
    <method name="readFixed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A fixed is decoded by just reading length bytes, and placing the bytes read
 into the bytes array, starting at index start.
 
 @param bytes
          The bytes array to populate.
 @param start
          The index in bytes to place the read bytes.
 @param length
          The number of bytes to read.]]>
      </doc>
    </method>
    <method name="skipFixed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips the fixed amount in the input stream.
 
 @param length
          The length of the fixed to skip.]]>
      </doc>
    </method>
    <method name="readEnum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Enums are decoded by reading the integer representation of the enum.
 
 @return The integer rep of the Enum.]]>
      </doc>
    </method>
    <method name="readArrayStart" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Array starts with a 1 if the array size is larger than 0, else it starts
 with a 0.
 
 @return 1 if the array size is larger than 0, else 0.]]>
      </doc>
    </method>
    <method name="arrayNext" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Each element of the array is prefixed with 1. The end of the array is a 0.
 
 @return 0 if there are no more elements in the array, else return 1.]]>
      </doc>
    </method>
    <method name="skipArray" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the array element prefix, or the end of the array.
 
 @return 0 if we are at the end of the array, else 1.]]>
      </doc>
    </method>
    <method name="readMapStart" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mapNext" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipMap" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Union index decoded as an Integer using the int decoding defined in this
 class.
 
 @return the union index.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class that will decode Avro types, whose sort order can be determined by a
 memcmp. Decodes avro types encoded with the MemcmpEncoder class. See that
 class for information on how each type of value is encoded.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.io.MemcmpDecoder -->
  <!-- start class com.cloudera.cdk.data.hbase.avro.io.MemcmpEncoder -->
  <class name="MemcmpEncoder" extends="org.apache.avro.io.Encoder"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MemcmpEncoder" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeNull"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A boolean is encoded as a byte, with 1 being true, and 0 being false.
 
 @param b
          The boolean to encode.]]>
      </doc>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[An int is written by flipping the sign bit, and writing it as a big endian
 int.
 
 @param n
          The int to encode.]]>
      </doc>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A long is written by flipping the sign bit, and writing it as a big endian
 long.
 
 @param n
          The long to encode.]]>
      </doc>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A float is written as 4 bytes. It is encoded as a 32 bit integer using the
 int encoding defined in this class. If it is a negative number, the
 complement of the 31 bits (every bit except the sign bit) is taken. This is
 to ensure proper ordering of negative numbers.
 
 @param f
          The float to encode.]]>
      </doc>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A double is written as 8 bytes. It is encoded as a 64 bit long using the
 long encoding defined in this class. If it is a negative number, the
 complement of the 63 bits (every bit except the sign bit) is taken. This is
 to ensure proper ordering of negative numbers.
 
 @param d
          The double to encode.]]>
      </doc>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="org.apache.avro.util.Utf8"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Strings are encoded by fetching the bytes of the UTF8 encoding, and using
 the writeBytes method of this class.
 
 @param utf8
          The utf8 string to encode.]]>
      </doc>
    </method>
    <method name="writeFixed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fixed values are encoded as the raw bytes.
 
 @param bytes
          The bytes to encode.
 @param start
          The start of the byte array to encode.
 @param len
          The length of the byte array to encode.]]>
      </doc>
    </method>
    <method name="writeBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Bytes are encoded by writing all bytes out as themselves, except for bytes
 of value 0x00. Bytes of value 0x00 are encoded as two bytes, 0x00 0x01. The
 end marker is signified by two 0x00 bytes. This guarantees that the end
 marker is the least possible value.
 
 @param bytes
          The bytes to encode.]]>
      </doc>
    </method>
    <method name="writeBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Bytes are encoded by writing all bytes out as themselves, except for bytes
 of value 0x00. Bytes of value 0x00 are encoded as two bytes, 0x00 0x01. The
 end marker is signified by two 0x00 bytes. This guarantees that the end
 marker is the least possible value.
 
 @param bytes
          The bytes to encode.
 @param start
          The start of the byte array to encode.
 @param len
          The length of the byte array to encode.]]>
      </doc>
    </method>
    <method name="writeEnum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Enums are encoded using the Integer encoding of this class.]]>
      </doc>
    </method>
    <method name="writeArrayStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setItemCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemCount" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Each item in an array is prepended by a 1 byte. This is to ensure that one
 array longer than another with equal elements up to that point will always
 be greater.]]>
      </doc>
    </method>
    <method name="writeArrayEnd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Arrays are appended with a 0 byte.]]>
      </doc>
    </method>
    <method name="writeMapStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Memcmp encoding for maps not supported, since ordering of Map in Avro is
 undefined.]]>
      </doc>
    </method>
    <method name="writeMapEnd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Memcmp encoding for maps not supported, since ordering of Map in Avro is
 undefined.]]>
      </doc>
    </method>
    <method name="writeIndex"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unionIndex" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Union indexes are written using the int encoding of this class.
 
 @param unionIndex
          The union index to encode.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class that will encode Avro types, whose sort order can be determined by a
 memcmp.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.avro.io.MemcmpEncoder -->
</package>
<package name="com.cloudera.cdk.data.hbase.filters">
  <!-- start interface com.cloudera.cdk.data.hbase.filters.EntityFilter -->
  <interface name="EntityFilter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getFilter" return="org.apache.hadoop.hbase.filter.Filter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns The HBase Filter Object
 @return Filter]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface for creating server side HBase filters.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.filters.EntityFilter -->
  <!-- start class com.cloudera.cdk.data.hbase.filters.RegexEntityFilter -->
  <class name="RegexEntityFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.hbase.filters.EntityFilter"/>
    <constructor name="RegexEntityFilter" type="com.cloudera.cdk.data.dao.EntitySchema, com.cloudera.cdk.data.hbase.EntitySerDe&lt;?&gt;, java.lang.String, java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RegexEntityFilter" type="com.cloudera.cdk.data.dao.EntitySchema, com.cloudera.cdk.data.hbase.EntitySerDe&lt;?&gt;, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFilter" return="org.apache.hadoop.hbase.filter.Filter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An EntityFilter that will perform a regular expression filter on an entity's
 field.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.filters.RegexEntityFilter -->
  <!-- start class com.cloudera.cdk.data.hbase.filters.SingleFieldEntityFilter -->
  <class name="SingleFieldEntityFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.hbase.filters.EntityFilter"/>
    <constructor name="SingleFieldEntityFilter" type="com.cloudera.cdk.data.dao.EntitySchema, com.cloudera.cdk.data.hbase.EntitySerDe&lt;?&gt;, java.lang.String, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SingleFieldEntityFilter" type="com.cloudera.cdk.data.dao.EntitySchema, com.cloudera.cdk.data.hbase.EntitySerDe&lt;?&gt;, java.lang.String, java.lang.Object, org.apache.hadoop.hbase.filter.CompareFilter.CompareOp"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFilter" return="org.apache.hadoop.hbase.filter.Filter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An EntityFilter that will perform an equality filter on a single entity
 field.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.filters.SingleFieldEntityFilter -->
</package>
<package name="com.cloudera.cdk.data.hbase.manager">
  <!-- start class com.cloudera.cdk.data.hbase.manager.DefaultSchemaManager -->
  <class name="DefaultSchemaManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.dao.SchemaManager"/>
    <constructor name="DefaultSchemaManager" type="org.apache.hadoop.hbase.client.HTablePool"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor which uses the default managed schema table name, which is
 managed_schemas.
 
 @param tablePool
          The pool of HBase tables]]>
      </doc>
    </constructor>
    <constructor name="DefaultSchemaManager" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DefaultSchemaManager" type="com.cloudera.cdk.data.hbase.manager.ManagedSchemaDao"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hasManagedSchema" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
    </method>
    <method name="getKeySchema" return="com.cloudera.cdk.data.dao.KeySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
    </method>
    <method name="getEntitySchema" return="com.cloudera.cdk.data.dao.EntitySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
    </method>
    <method name="getEntitySchema" return="com.cloudera.cdk.data.dao.EntitySchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <param name="version" type="int"/>
    </method>
    <method name="getEntitySchemas" return="java.util.Map&lt;java.lang.Integer, com.cloudera.cdk.data.dao.EntitySchema&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
    </method>
    <method name="getEntityVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <param name="schema" type="com.cloudera.cdk.data.dao.EntitySchema"/>
    </method>
    <method name="createSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <param name="keySchemaStr" type="java.lang.String"/>
      <param name="entitySchemaStr" type="java.lang.String"/>
      <param name="schemaParserType" type="java.lang.String"/>
      <param name="keySerDeType" type="java.lang.String"/>
      <param name="entitySerDeType" type="java.lang.String"/>
    </method>
    <method name="migrateSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <param name="newSchemaStr" type="java.lang.String"/>
    </method>
    <method name="refreshManagedSchemaCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <doc>
      <![CDATA[Update the managedSchemaMap for the entry defined by tableName and
 entityName.
 
 @param tableName
          The table name of the managed schema
 @param entityName
          The entity name of the managed schema]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The Default SchemaManager implementation. It uses a ManagedSchemaDao
 implementation, passed in the constructor, to read schema metadata, and
 persist schema metadata for schema creations and migrations.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.manager.DefaultSchemaManager -->
  <!-- start class com.cloudera.cdk.data.hbase.manager.ManagedSchema -->
  <class name="ManagedSchema" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="ManagedSchema"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use {@link \#newBuilder()}.]]>
      </doc>
    </constructor>
    <constructor name="ManagedSchema" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.util.Map&lt;java.lang.String, java.lang.String&gt;, java.lang.Long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'name' field.]]>
      </doc>
    </method>
    <method name="getTable" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'table' field.]]>
      </doc>
    </method>
    <method name="getSchemaType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'schemaType' field.]]>
      </doc>
    </method>
    <method name="getKeySerDeType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'keySerDeType' field.]]>
      </doc>
    </method>
    <method name="getEntitySerDeType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'entitySerDeType' field.]]>
      </doc>
    </method>
    <method name="getKeySchema" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'keySchema' field.]]>
      </doc>
    </method>
    <method name="getEntitySchemas" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'entitySchemas' field.]]>
      </doc>
    </method>
    <method name="getConflictCheck" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'conflictCheck' field.]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new ManagedSchema RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"/>
      <doc>
      <![CDATA[Creates a new ManagedSchema RecordBuilder by copying an existing Builder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.manager.ManagedSchema"/>
      <doc>
      <![CDATA[Creates a new ManagedSchema RecordBuilder by copying an existing ManagedSchema instance]]>
      </doc>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.manager.ManagedSchema -->
  <!-- start class com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder -->
  <class name="ManagedSchema.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase&lt;com.cloudera.cdk.data.hbase.manager.ManagedSchema&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder&lt;com.cloudera.cdk.data.hbase.manager.ManagedSchema&gt;"/>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'name' field]]>
      </doc>
    </method>
    <method name="setName" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'name' field]]>
      </doc>
    </method>
    <method name="hasName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'name' field has been set]]>
      </doc>
    </method>
    <method name="clearName" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'name' field]]>
      </doc>
    </method>
    <method name="getTable" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'table' field]]>
      </doc>
    </method>
    <method name="setTable" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'table' field]]>
      </doc>
    </method>
    <method name="hasTable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'table' field has been set]]>
      </doc>
    </method>
    <method name="clearTable" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'table' field]]>
      </doc>
    </method>
    <method name="getSchemaType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'schemaType' field]]>
      </doc>
    </method>
    <method name="setSchemaType" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'schemaType' field]]>
      </doc>
    </method>
    <method name="hasSchemaType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'schemaType' field has been set]]>
      </doc>
    </method>
    <method name="clearSchemaType" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'schemaType' field]]>
      </doc>
    </method>
    <method name="getKeySerDeType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'keySerDeType' field]]>
      </doc>
    </method>
    <method name="setKeySerDeType" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'keySerDeType' field]]>
      </doc>
    </method>
    <method name="hasKeySerDeType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'keySerDeType' field has been set]]>
      </doc>
    </method>
    <method name="clearKeySerDeType" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'keySerDeType' field]]>
      </doc>
    </method>
    <method name="getEntitySerDeType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'entitySerDeType' field]]>
      </doc>
    </method>
    <method name="setEntitySerDeType" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'entitySerDeType' field]]>
      </doc>
    </method>
    <method name="hasEntitySerDeType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'entitySerDeType' field has been set]]>
      </doc>
    </method>
    <method name="clearEntitySerDeType" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'entitySerDeType' field]]>
      </doc>
    </method>
    <method name="getKeySchema" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'keySchema' field]]>
      </doc>
    </method>
    <method name="setKeySchema" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'keySchema' field]]>
      </doc>
    </method>
    <method name="hasKeySchema" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'keySchema' field has been set]]>
      </doc>
    </method>
    <method name="clearKeySchema" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'keySchema' field]]>
      </doc>
    </method>
    <method name="getEntitySchemas" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'entitySchemas' field]]>
      </doc>
    </method>
    <method name="setEntitySchemas" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Sets the value of the 'entitySchemas' field]]>
      </doc>
    </method>
    <method name="hasEntitySchemas" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'entitySchemas' field has been set]]>
      </doc>
    </method>
    <method name="clearEntitySchemas" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'entitySchemas' field]]>
      </doc>
    </method>
    <method name="getConflictCheck" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'conflictCheck' field]]>
      </doc>
    </method>
    <method name="setConflictCheck" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Sets the value of the 'conflictCheck' field]]>
      </doc>
    </method>
    <method name="hasConflictCheck" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'conflictCheck' field has been set]]>
      </doc>
    </method>
    <method name="clearConflictCheck" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'conflictCheck' field]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for ManagedSchema instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.manager.ManagedSchema.Builder -->
  <!-- start interface com.cloudera.cdk.data.hbase.manager.ManagedSchemaDao -->
  <interface name="ManagedSchemaDao"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getManagedSchemas" return="java.util.List&lt;com.cloudera.cdk.data.hbase.manager.ManagedSchemaDao.ManagedKeySchemaPair&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get all Managed Schemas from the persistence store.
 
 @return The list of ManagedKeySchemaPair instances]]>
      </doc>
    </method>
    <method name="getManagedSchema" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaDao.ManagedKeySchemaPair"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a ManagedSchema for the table name, entity name pair. Returns null if
 one doesn't exist.
 
 @param tableName
          The table name of the managed schema we are fetching
 @param entityName
          The entity name of the managed schema we are fetching
 @return The ManagedKeySchemaPair, or null if one doesn't exist.]]>
      </doc>
    </method>
    <method name="save" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey"/>
      <param name="schema" type="com.cloudera.cdk.data.hbase.manager.ManagedSchema"/>
      <doc>
      <![CDATA[Save a Managed schema to the persistence store.
 
 @param key
          The key (table name, entity name) of the ManagedSchema
 @param schema
          The ManagedSchema to save
 @return True if the save succeeded, or false if there wwas a conflict]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for fetching managed schemas from a persistence store. Managed
 schemas are defined by the ManagedSchema avro record. Dao implementations
 should be able to fetch these by key, defined by ManagedSchemaKey avro
 record, from the persistence store.
 
 ManagedSchemaKey is effectively a table name, entity name pair.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.data.hbase.manager.ManagedSchemaDao -->
  <!-- start class com.cloudera.cdk.data.hbase.manager.ManagedSchemaDao.ManagedKeySchemaPair -->
  <class name="ManagedSchemaDao.ManagedKeySchemaPair" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ManagedSchemaDao.ManagedKeySchemaPair" type="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey, com.cloudera.cdk.data.hbase.manager.ManagedSchema"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKey" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getManagedSchema" return="com.cloudera.cdk.data.hbase.manager.ManagedSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Encapsulates a ManagedSchemaKey, and ManagedSchema. This is returned from
 rows of the persistence store.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.manager.ManagedSchemaDao.ManagedKeySchemaPair -->
  <!-- start class com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion -->
  <class name="ManagedSchemaEntityVersion" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="ManagedSchemaEntityVersion"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use {@link \#newBuilder()}.]]>
      </doc>
    </constructor>
    <constructor name="ManagedSchemaEntityVersion" type="java.util.Map&lt;java.lang.String, java.lang.Integer&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getSchemaVersion" return="java.util.Map&lt;java.lang.String, java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'schemaVersion' field.]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new ManagedSchemaEntityVersion RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion.Builder"/>
      <doc>
      <![CDATA[Creates a new ManagedSchemaEntityVersion RecordBuilder by copying an existing Builder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion"/>
      <doc>
      <![CDATA[Creates a new ManagedSchemaEntityVersion RecordBuilder by copying an existing ManagedSchemaEntityVersion instance]]>
      </doc>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion -->
  <!-- start class com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion.Builder -->
  <class name="ManagedSchemaEntityVersion.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase&lt;com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder&lt;com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion&gt;"/>
    <method name="getSchemaVersion" return="java.util.Map&lt;java.lang.String, java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'schemaVersion' field]]>
      </doc>
    </method>
    <method name="setSchemaVersion" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.Map&lt;java.lang.String, java.lang.Integer&gt;"/>
      <doc>
      <![CDATA[Sets the value of the 'schemaVersion' field]]>
      </doc>
    </method>
    <method name="hasSchemaVersion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'schemaVersion' field has been set]]>
      </doc>
    </method>
    <method name="clearSchemaVersion" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'schemaVersion' field]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for ManagedSchemaEntityVersion instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.manager.ManagedSchemaEntityVersion.Builder -->
  <!-- start class com.cloudera.cdk.data.hbase.manager.ManagedSchemaHBaseDao -->
  <class name="ManagedSchemaHBaseDao" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.hbase.manager.ManagedSchemaDao"/>
    <constructor name="ManagedSchemaHBaseDao" type="org.apache.hadoop.hbase.client.HTablePool"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor which uses the default managed schema table name, which is
 managed_schemas.
 
 @param tablePool
          The pool of HBase tables]]>
      </doc>
    </constructor>
    <constructor name="ManagedSchemaHBaseDao" type="org.apache.hadoop.hbase.client.HTablePool, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getManagedSchemas" return="java.util.List&lt;com.cloudera.cdk.data.hbase.manager.ManagedSchemaDao.ManagedKeySchemaPair&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getManagedSchema" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaDao.ManagedKeySchemaPair"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="entityName" type="java.lang.String"/>
    </method>
    <method name="save" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey"/>
      <param name="schema" type="com.cloudera.cdk.data.hbase.manager.ManagedSchema"/>
    </method>
    <field name="DEFAULT_MANAGED_SCHEMA_TABLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Default HBase table where this schema metadata is stored.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[ManagedSchemaDao implementation backed by an HBase table. All of the managed
 schemas are persisted to a table called "managed_schemas" unless otherwise
 specified in the constructor.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.manager.ManagedSchemaHBaseDao -->
  <!-- start class com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey -->
  <class name="ManagedSchemaKey" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="ManagedSchemaKey"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use {@link \#newBuilder()}.]]>
      </doc>
    </constructor>
    <constructor name="ManagedSchemaKey" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getTable" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'table' field.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'name' field.]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new ManagedSchemaKey RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey.Builder"/>
      <doc>
      <![CDATA[Creates a new ManagedSchemaKey RecordBuilder by copying an existing Builder]]>
      </doc>
    </method>
    <method name="newBuilder" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey"/>
      <doc>
      <![CDATA[Creates a new ManagedSchemaKey RecordBuilder by copying an existing ManagedSchemaKey instance]]>
      </doc>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey -->
  <!-- start class com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey.Builder -->
  <class name="ManagedSchemaKey.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase&lt;com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder&lt;com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey&gt;"/>
    <method name="getTable" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'table' field]]>
      </doc>
    </method>
    <method name="setTable" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'table' field]]>
      </doc>
    </method>
    <method name="hasTable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'table' field has been set]]>
      </doc>
    </method>
    <method name="clearTable" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'table' field]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'name' field]]>
      </doc>
    </method>
    <method name="setName" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'name' field]]>
      </doc>
    </method>
    <method name="hasName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'name' field has been set]]>
      </doc>
    </method>
    <method name="clearName" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'name' field]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for ManagedSchemaKey instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.manager.ManagedSchemaKey.Builder -->
</package>
<package name="com.cloudera.cdk.data.hbase.tool">
  <!-- start class com.cloudera.cdk.data.hbase.tool.SchemaTool -->
  <class name="SchemaTool" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SchemaTool" type="org.apache.hadoop.hbase.client.HBaseAdmin, com.cloudera.cdk.data.dao.SchemaManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createOrMigrateSchemaDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schemaDirectory" type="java.lang.String"/>
      <param name="createTableAndFamilies" type="boolean"/>
      <doc>
      <![CDATA[Scans the schemaDirectory for avro schemas, and creates or migrates HBase
 Common managed schemas managed by this instances entity manager.
 
 @param schemaDirectory
          The directory to recursively scan for avro schema files. This
          directory can be a directory on the classpath, including a
          directory that is embeddded in a jar on the classpath. In both of
          those cases, the schemaDirectory should be prefixed with
          classpath:
 @param createTableAndFamilies
          If true, will create the table for each schema if it doesn't
          exist, and will create families if they don't exist.]]>
      </doc>
    </method>
    <method name="createOrMigrateSchemaFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="keySchemaFilePath" type="java.lang.String"/>
      <param name="entitySchemaFilePath" type="java.lang.String"/>
      <param name="createTableAndFamilies" type="boolean"/>
      <doc>
      <![CDATA[Creates a new managed schema, or migrates an existing one if one exists for
 the table name, entity name pair.
 
 @param tableName
          The name of the table we'll be creating or migrating a schema for.
 @param keySchemaFilePath
          The absolute file path to the key schema file.
 @param entitySchemaFilePath
          The absolute file path to the entity schema file.
 @param createTableAndFamilies
          If true, will create the table for this schema if it doesn't
          exist, and will create families if they don't exist.]]>
      </doc>
    </method>
    <method name="createOrMigrateSchemaFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="keySchemaFile" type="java.io.File"/>
      <param name="entitySchemaFile" type="java.io.File"/>
      <param name="createTableAndFamilies" type="boolean"/>
      <doc>
      <![CDATA[Creates a new managed schema, or migrates an existing one if one exists for
 the table name, entity name pair.
 
 @param tableName
          The name of the table we'll be creating or migrating a schema for.
 @param keySchemaFile
          The key schema file.
 @param entitySchemaFile
          The entity schema file.
 @param createTableAndFamilies
          If true, will create the table for this schema if it doesn't
          exist, and will create families if they don't exist.]]>
      </doc>
    </method>
    <method name="createOrMigrateSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <param name="keySchemaString" type="java.lang.String"/>
      <param name="entitySchemaString" type="java.lang.String"/>
      <param name="createTableAndFamilies" type="boolean"/>
      <doc>
      <![CDATA[Creates a new managed schema, or migrates an existing one if one exists for
 the table name, entity name pair.
 
 @param tableName
          The name of the table we'll be creating or migrating a schema for.
 @param keySchemaString
          The key schema
 @param entitySchemaString
          The entity schema
 @param createTableAndFamilies
          If true, will create the table for this schema if it doesn't
          exist, and will create families if they don't exist.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class for managing Managed Schemas in HBase Common.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hbase.tool.SchemaTool -->
</package>
<package name="com.cloudera.cdk.data.hcatalog">
  <!-- start class com.cloudera.cdk.data.hcatalog.HCatalogDatasetRepository -->
  <class name="HCatalogDatasetRepository" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.DatasetRepository"/>
    <constructor name="HCatalogDatasetRepository"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Create an HCatalog dataset repository with managed tables. The location of the
 data directory is determined by the setting of
 <code>hive.metastore.warehouse.dir</code>, read from <i>hive-site.xml</i> on the
 classpath, or if no such file is found then the default for this property.
 </p>]]>
      </doc>
    </constructor>
    <constructor name="HCatalogDatasetRepository" type="java.net.URI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Create an HCatalog dataset repository with external tables.
 </p>
 @param uri the root directory for datasets
 @since 0.3.0]]>
      </doc>
    </constructor>
    <constructor name="HCatalogDatasetRepository" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Create an HCatalog dataset repository with external tables.
 </p>
 @param fileSystem    the filesystem to store datasets in
 @param rootDirectory the root directory for datasets]]>
      </doc>
    </constructor>
    <method name="create" return="com.cloudera.cdk.data.Dataset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="descriptor" type="com.cloudera.cdk.data.DatasetDescriptor"/>
    </method>
    <method name="update" return="com.cloudera.cdk.data.Dataset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="descriptor" type="com.cloudera.cdk.data.DatasetDescriptor"/>
    </method>
    <method name="get" return="com.cloudera.cdk.data.Dataset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="drop" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[<p>
 A {@link DatasetRepository} that uses the Hive/HCatalog metastore for metadata,
 and stores data in a Hadoop {@link FileSystem}.
 </p>
 <p>
 The location of the data directory is either chosen by Hive/HCatalog (so called
 "managed tables"), or specified when creating an instance of this class by providing
 a {@link FileSystem}, and a root directory in the constructor ("external tables").
 </p>
 <p>
 The primary methods of interest will be
 {@link #create(String, DatasetDescriptor)}, {@link #get(String)}, and
 {@link #drop(String)} which create a new dataset, load an existing
 dataset, or delete an existing dataset, respectively. Once a dataset has been created
 or loaded, users can invoke the appropriate {@link Dataset} methods to get a reader
 or writer as needed.
 </p>

 @see DatasetRepository
 @see Dataset]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hcatalog.HCatalogDatasetRepository -->
  <!-- start class com.cloudera.cdk.data.hcatalog.HCatalogDatasetRepository.Builder -->
  <class name="HCatalogDatasetRepository.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Supplier&lt;com.cloudera.cdk.data.hcatalog.HCatalogDatasetRepository&gt;"/>
    <constructor name="HCatalogDatasetRepository.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="rootDirectory" return="com.cloudera.cdk.data.hcatalog.HCatalogDatasetRepository.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[The root directory for dataset files.]]>
      </doc>
    </method>
    <method name="rootDirectory" return="com.cloudera.cdk.data.hcatalog.HCatalogDatasetRepository.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[The root directory for dataset files.]]>
      </doc>
    </method>
    <method name="fileSystem" return="com.cloudera.cdk.data.hcatalog.HCatalogDatasetRepository.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileSystem" type="org.apache.hadoop.fs.FileSystem"/>
      <doc>
      <![CDATA[The {@link FileSystem} to store dataset files in. Optional. If not
 specified, the default filesystem will be used.]]>
      </doc>
    </method>
    <method name="configuration" return="com.cloudera.cdk.data.hcatalog.HCatalogDatasetRepository.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configuration" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[The {@link Configuration} used to find the {@link FileSystem}. Optional. If not
 specified, the default configuration will be used.]]>
      </doc>
    </method>
    <method name="get" return="com.cloudera.cdk.data.hcatalog.HCatalogDatasetRepository"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A fluent builder to aid in the construction of {@link HCatalogDatasetRepository}
 instances.
 @since 0.3.0]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.hcatalog.HCatalogDatasetRepository.Builder -->
</package>
<package name="com.cloudera.cdk.data.partition">
  <!-- start class com.cloudera.cdk.data.partition.DayOfMonthFieldPartitioner -->
  <class name="DayOfMonthFieldPartitioner" extends="com.cloudera.cdk.data.partition.CalendarFieldPartitioner"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DayOfMonthFieldPartitioner" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="valueToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.DayOfMonthFieldPartitioner -->
  <!-- start class com.cloudera.cdk.data.partition.HashFieldPartitioner -->
  <class name="HashFieldPartitioner" extends="com.cloudera.cdk.data.FieldPartitioner"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HashFieldPartitioner" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HashFieldPartitioner" type="java.lang.String, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="valueFromString" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.HashFieldPartitioner -->
  <!-- start class com.cloudera.cdk.data.partition.HourFieldPartitioner -->
  <class name="HourFieldPartitioner" extends="com.cloudera.cdk.data.partition.CalendarFieldPartitioner"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HourFieldPartitioner" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="valueToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.HourFieldPartitioner -->
  <!-- start class com.cloudera.cdk.data.partition.IdentityFieldPartitioner -->
  <class name="IdentityFieldPartitioner" extends="com.cloudera.cdk.data.FieldPartitioner"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IdentityFieldPartitioner" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="valueFromString" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.IdentityFieldPartitioner -->
  <!-- start class com.cloudera.cdk.data.partition.IntRangeFieldPartitioner -->
  <class name="IntRangeFieldPartitioner" extends="com.cloudera.cdk.data.FieldPartitioner"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IntRangeFieldPartitioner" type="java.lang.String, int[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="valueFromString" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.IntRangeFieldPartitioner -->
  <!-- start class com.cloudera.cdk.data.partition.ListFieldPartitioner -->
  <class name="ListFieldPartitioner" extends="com.cloudera.cdk.data.FieldPartitioner"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ListFieldPartitioner" type="java.lang.String, java.util.List&lt;java.util.Set&lt;?&gt;&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="valueFromString" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.ListFieldPartitioner -->
  <!-- start class com.cloudera.cdk.data.partition.MinuteFieldPartitioner -->
  <class name="MinuteFieldPartitioner" extends="com.cloudera.cdk.data.partition.CalendarFieldPartitioner"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MinuteFieldPartitioner" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="valueToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.MinuteFieldPartitioner -->
  <!-- start class com.cloudera.cdk.data.partition.MonthFieldPartitioner -->
  <class name="MonthFieldPartitioner" extends="com.cloudera.cdk.data.partition.CalendarFieldPartitioner"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MonthFieldPartitioner" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="valueToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.MonthFieldPartitioner -->
  <!-- start class com.cloudera.cdk.data.partition.PartitionFunctions -->
  <class name="PartitionFunctions" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PartitionFunctions"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hash" return="com.cloudera.cdk.data.FieldPartitioner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="buckets" type="int"/>
    </method>
    <method name="hash" return="com.cloudera.cdk.data.FieldPartitioner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="buckets" type="int"/>
    </method>
    <method name="identity" return="com.cloudera.cdk.data.FieldPartitioner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="buckets" type="int"/>
    </method>
    <method name="range" return="com.cloudera.cdk.data.FieldPartitioner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="upperBounds" type="int[]"/>
    </method>
    <method name="range" return="com.cloudera.cdk.data.FieldPartitioner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="upperBounds" type="java.lang.Comparable[]"/>
    </method>
    <method name="year" return="com.cloudera.cdk.data.FieldPartitioner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="month" return="com.cloudera.cdk.data.FieldPartitioner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="day" return="com.cloudera.cdk.data.FieldPartitioner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="hour" return="com.cloudera.cdk.data.FieldPartitioner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="minute" return="com.cloudera.cdk.data.FieldPartitioner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Convenience class so you can say, for example, <code>hash("username", 2)</code> in
 JEXL.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.PartitionFunctions -->
  <!-- start class com.cloudera.cdk.data.partition.RangeFieldPartitioner -->
  <class name="RangeFieldPartitioner" extends="com.cloudera.cdk.data.FieldPartitioner"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RangeFieldPartitioner" type="java.lang.String, java.lang.Comparable[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="valueFromString" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
    </method>
    <method name="getUpperBounds" return="java.util.List&lt;java.lang.Comparable&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.RangeFieldPartitioner -->
  <!-- start class com.cloudera.cdk.data.partition.YearFieldPartitioner -->
  <class name="YearFieldPartitioner" extends="com.cloudera.cdk.data.partition.CalendarFieldPartitioner"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="YearFieldPartitioner" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.cloudera.cdk.data.partition.YearFieldPartitioner -->
</package>
<package name="com.cloudera.cdk.data.spi">
  <!-- start class com.cloudera.cdk.data.spi.AbstractDatasetReader -->
  <class name="AbstractDatasetReader" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.data.DatasetReader&lt;E&gt;"/>
    <constructor name="AbstractDatasetReader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="read" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A common DatasetReader base class to simplify implementations.

 @param <E> The type of entities returned by this DatasetReader.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.data.spi.AbstractDatasetReader -->
</package>
<package name="com.cloudera.cdk.morphline.api">
  <!-- start interface com.cloudera.cdk.morphline.api.Command -->
  <interface name="Command"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="notify"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="notification" type="com.cloudera.cdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Processes the given notification on the control plane of the subtree rooted at this command.]]>
      </doc>
    </method>
    <method name="process" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="com.cloudera.cdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Processes the given record on the data plane of this command.
 
 @return true to indicate that processing shall continue, false to indicate that backtracking
         shall be done]]>
      </doc>
    </method>
    <method name="getParent" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the parent of this command.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A command transforms a record into zero or more records.
 
 A command has a boolean return code, indicating success or failure. All record handlers in a
 morphline implement this interface. Commands are chained together. The parent of a command A is
 the command B that passes records to A.
 
 Data is sent on the data plane whereas notifications are sent on the control plane, which is a
 separate communication channel.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.morphline.api.Command -->
  <!-- start interface com.cloudera.cdk.morphline.api.CommandBuilder -->
  <interface name="CommandBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names with which this command can be invoked.
 
 The returned set can contain synonyms to enable backwards compatible name changes.]]>
      </doc>
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
      <doc>
      <![CDATA[Creates and returns a command rooted at the given morphline config.
 
 The command will feed records into child. The command will have parent as it's parent.
 Additional parameters can be passed via the morphline context.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to create instances of morphline commands.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.morphline.api.CommandBuilder -->
  <!-- start interface com.cloudera.cdk.morphline.api.ExceptionHandler -->
  <interface name="ExceptionHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handleException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="record" type="com.cloudera.cdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Handle the given exception resulting from the given input record (the record can be null)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Morphline-wide default handler that commands can choose to use to handle exceptions.
 
 Mission critical, large-scale online production systems need to make progress without downtime
 despite some issues. Thus, the recommendation is that implementations of this handler rethrow
 exceptions in test mode, but try to log and continue in production mode, if that's considered
 appropriate and feasible.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.morphline.api.ExceptionHandler -->
  <!-- start class com.cloudera.cdk.morphline.api.MorphlineCompilationException -->
  <class name="MorphlineCompilationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MorphlineCompilationException" type="java.lang.String, com.typesafe.config.Config"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MorphlineCompilationException" type="java.lang.String, com.typesafe.config.Config, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MorphlineCompilationException" type="java.lang.String, com.typesafe.config.Config, java.lang.Throwable, com.cloudera.cdk.morphline.api.CommandBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Indicates a parse error.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.api.MorphlineCompilationException -->
  <!-- start class com.cloudera.cdk.morphline.api.MorphlineContext -->
  <class name="MorphlineContext" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[For public access use {@link Builder#build()} instead]]>
      </doc>
    </constructor>
    <method name="getExceptionHandler" return="com.cloudera.cdk.morphline.api.ExceptionHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMetricRegistry" return="com.codahale.metrics.MetricRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCommandBuilder" return="java.lang.Class&lt;com.cloudera.cdk.morphline.api.CommandBuilder&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builderName" type="java.lang.String"/>
    </method>
    <method name="importCommandBuilders"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="importSpecs" type="java.util.Collection&lt;java.lang.String&gt;"/>
    </method>
    <doc>
    <![CDATA[Additional user defined parameters that will be passed to all morphline commands.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.api.MorphlineContext -->
  <!-- start class com.cloudera.cdk.morphline.api.MorphlineContext.Builder -->
  <class name="MorphlineContext.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MorphlineContext.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setExceptionHandler" return="com.cloudera.cdk.morphline.api.MorphlineContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exceptionHandler" type="com.cloudera.cdk.morphline.api.ExceptionHandler"/>
    </method>
    <method name="setMetricRegistry" return="com.cloudera.cdk.morphline.api.MorphlineContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricRegistry" type="com.codahale.metrics.MetricRegistry"/>
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.MorphlineContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="create" return="com.cloudera.cdk.morphline.api.MorphlineContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <field name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Helper to construct a {@link MorphlineContext} instance.
 
 Example usage: 
 
 <pre>
 MorphlineContext context = new MorphlineContext.Builder().setMetricRegistry(new MetricRegistry()).build();
 </pre>]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.api.MorphlineContext.Builder -->
  <!-- start class com.cloudera.cdk.morphline.api.MorphlineRuntimeException -->
  <class name="MorphlineRuntimeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MorphlineRuntimeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MorphlineRuntimeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MorphlineRuntimeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Base class of all morphline exceptions.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.api.MorphlineRuntimeException -->
  <!-- start class com.cloudera.cdk.morphline.api.Record -->
  <class name="Record" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Record"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="copy" return="com.cloudera.cdk.morphline.api.Record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFields" return="com.google.common.collect.ListMultimap&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="getFirstValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <method name="replaceValues"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="removeAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <method name="putIfAbsent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A record is a set of named fields where each field has a list of one or more values.
 
 A value can be of any type, i.e. any Java Object. That is, a record is a {@link ListMultimap} as
 in Guava#s {@link ArrayListMultimap}. Note that a field can be multi-valued and that any two
 records need not use common field names. This flexible data model corresponds exactly to the
 characteristics of the Solr/Lucene data model (i.e. a record is a SolrInputDocument). A field
 with zero values is removed from the record - it does not exist as such.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.api.Record -->
</package>
<package name="com.cloudera.cdk.morphline.avro">
  <!-- start class com.cloudera.cdk.morphline.avro.ExtractAvroPathsBuilder -->
  <class name="ExtractAvroPathsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractAvroPathsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that uses zero or more avro path expressions to extract values from an Avro object.
 
 The Avro input object is expected to be contained in the {@link Fields#ATTACHMENT_BODY}
 
 Each expression consists of a record output field name (on the left side of the colon ':') as
 well as zero or more path steps (on the right hand side), each path step separated by a '/'
 slash. Avro arrays are traversed with the '[]' notation.
 
 The result of a path expression is a list of objects, each of which is added to the given record
 output field.
 
 The path language supports all Avro concepts, including nested structures, records, arrays, maps,
 unions, etc, as well as a flatten option that collects the primitives in a subtree into a flat
 list.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.avro.ExtractAvroPathsBuilder -->
  <!-- start class com.cloudera.cdk.morphline.avro.ExtractAvroTreeBuilder -->
  <class name="ExtractAvroTreeBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractAvroTreeBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts an attached Avro datum to a morphline record by recursively walking the
 Avro tree and extracting all data into a single morphline record, with fields named by their path
 in the Avro tree.
 
 The Avro input object is expected to be contained in the {@link Fields#ATTACHMENT_BODY}
 
 This kind of mapping is useful for simple Avro schemas, but a rather simplistic (and perhaps
 expensive) approach for complex Avro schemas.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.avro.ExtractAvroTreeBuilder -->
  <!-- start class com.cloudera.cdk.morphline.avro.ReadAvroBuilder -->
  <class name="ReadAvroBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadAvroBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="AVRO_MEMORY_MIME_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The MIME type identifier that will be filled into output records]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Command that parses an InputStream that contains Avro data; for each Avro datum, the command
 emits a morphline record containing the datum as an attachment in {@link Fields#ATTACHMENT_BODY}.
 
 The Avro schema that was used to write the Avro data must be explicitly supplied. Optionally, the
 Avro schema that shall be used for reading can be supplied as well.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.avro.ReadAvroBuilder -->
  <!-- start class com.cloudera.cdk.morphline.avro.ReadAvroContainerBuilder -->
  <class name="ReadAvroContainerBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadAvroContainerBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="MIME_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The MIME type that input attachments shall have]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Command that parses an InputStream that contains Avro binary container file data; for each Avro
 datum, the command emits a morphline record containing the datum as an attachment in
 {@link Fields#ATTACHMENT_BODY}.
 
 The Avro schema that was used to write the Avro data is retrieved from the container. Optionally, the
 Avro schema that shall be used for reading can be supplied as well.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.avro.ReadAvroContainerBuilder -->
</package>
<package name="com.cloudera.cdk.morphline.base">
  <!-- start class com.cloudera.cdk.morphline.base.AbstractCommand -->
  <class name="AbstractCommand" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.Command"/>
    <constructor name="AbstractCommand" type="com.typesafe.config.Config, com.cloudera.cdk.morphline.api.Command, com.cloudera.cdk.morphline.api.Command, com.cloudera.cdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getParent" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChild" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getConfig" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getContext" return="com.cloudera.cdk.morphline.api.MorphlineContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getConfigs" return="com.cloudera.cdk.morphline.base.Configs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="notify"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="notification" type="com.cloudera.cdk.morphline.api.Record"/>
    </method>
    <method name="doNotify"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="notification" type="com.cloudera.cdk.morphline.api.Record"/>
    </method>
    <method name="process" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="com.cloudera.cdk.morphline.api.Record"/>
    </method>
    <method name="doProcess" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="com.cloudera.cdk.morphline.api.Record"/>
    </method>
    <method name="validateArguments"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getCounter" return="com.codahale.metrics.Counter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
    </method>
    <method name="getHistogram" return="com.codahale.metrics.Histogram"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
    </method>
    <method name="getMeter" return="com.codahale.metrics.Meter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
    </method>
    <method name="getTimer" return="com.codahale.metrics.Timer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
    </method>
    <method name="buildCommandChain" return="java.util.List&lt;com.cloudera.cdk.morphline.api.Command&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="rootConfig" type="com.typesafe.config.Config"/>
      <param name="configKey" type="java.lang.String"/>
      <param name="finalChild" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="ignoreNotifications" type="boolean"/>
      <doc>
      <![CDATA[Factory method to create the chain of commands rooted at the given rootConfig. The last command
 in the chain will feed records into finalChild.
 
 @param ignoreNotifications
          if true indicates don't forward notifications at the end of the chain of commands.
          This is a feature that multi-branch commands like tryRules and ifThenElse need to
          avoid sending a notification multiple times to finalChild, once from each branch.]]>
      </doc>
    </method>
    <method name="buildCommand" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cmdConfig" type="com.typesafe.config.Config"/>
      <param name="currentParent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="finalChild" type="com.cloudera.cdk.morphline.api.Command"/>
      <doc>
      <![CDATA[Factory method to create a command rooted at the given cmdConfig. The command will feed records
 into finalChild. The command will have currentParent as it's parent.]]>
      </doc>
    </method>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Base class for convenient implementation of {@link Command} classes.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.base.AbstractCommand -->
  <!-- start class com.cloudera.cdk.morphline.base.Compiler -->
  <class name="Compiler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Compiler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compile" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="morphlineFile" type="java.io.File"/>
      <param name="morphlineId" type="java.lang.String"/>
      <param name="morphlineContext" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
      <param name="finalChild" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="overrides" type="com.typesafe.config.Config[]"/>
      <doc>
      <![CDATA[Parses the given morphlineFile, then finds the morphline with the given morphlineId within,
 then compiles the morphline and returns the corresponding morphline command. The returned
 command will feed records into finalChild.]]>
      </doc>
    </method>
    <method name="parse" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="overrides" type="com.typesafe.config.Config[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Loads the given config file from the local file system]]>
      </doc>
    </method>
    <method name="find" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="morphlineId" type="java.lang.String"/>
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="nameForErrorMsg" type="java.lang.String"/>
      <doc>
      <![CDATA[Finds the given morphline id within the given morphline config, using the given nameForErrorMsg
 for error reporting.]]>
      </doc>
    </method>
    <method name="compile" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="morphlineConfig" type="com.typesafe.config.Config"/>
      <param name="morphlineContext" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
      <param name="finalChild" type="com.cloudera.cdk.morphline.api.Command"/>
      <doc>
      <![CDATA[Compiles the given morphline config using the given morphline context. The returned command
 will feed records into finalChild or into /dev/null if finalChild is null.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tool to parse and compile a morphline file or morphline config.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.base.Compiler -->
  <!-- start class com.cloudera.cdk.morphline.base.Configs -->
  <class name="Configs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Configs"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="validateArguments"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
    </method>
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="java.lang.String"/>
    </method>
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getStringList" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="java.util.List&lt;java.lang.String&gt;"/>
    </method>
    <method name="getStringList" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getConfigList" return="java.util.List&lt;? extends com.typesafe.config.Config&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="java.util.List&lt;? extends com.typesafe.config.Config&gt;"/>
    </method>
    <method name="getConfigList" return="java.util.List&lt;? extends com.typesafe.config.Config&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getConfig" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="com.typesafe.config.Config"/>
    </method>
    <method name="getConfig" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="boolean"/>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="int"/>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="long"/>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="double"/>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getCharset" return="java.nio.charset.Charset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="java.nio.charset.Charset"/>
    </method>
    <doc>
    <![CDATA[Helpers to traverse and read parts of a HOCON data structure.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.base.Configs -->
  <!-- start class com.cloudera.cdk.morphline.base.FaultTolerance -->
  <class name="FaultTolerance" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.ExceptionHandler"/>
    <constructor name="FaultTolerance" type="boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FaultTolerance" type="boolean, boolean, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="handleException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="record" type="com.cloudera.cdk.morphline.api.Record"/>
    </method>
    <field name="IS_PRODUCTION_MODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IS_IGNORING_RECOVERABLE_EXCEPTIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECOVERABLE_EXCEPTION_CLASSES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Mission critical, large-scale online production systems need to make progress without downtime
 despite some issues.
 
 Some program exceptions tend to be transient, in which case the corresponding task can be
 retried. Examples include network connection errors, timeouts, etc. These are called recoverable
 exceptions.
 
 The isIgnoringRecoverableExceptions should only be enabled if an exception misclassification bug
 has been identified.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.base.FaultTolerance -->
  <!-- start class com.cloudera.cdk.morphline.base.FieldExpression -->
  <class name="FieldExpression" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FieldExpression" type="java.lang.String, com.typesafe.config.Config"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="evaluate" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="com.cloudera.cdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Returns the values of a {@link Record} referred to by the given field expression]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helper to fetch the values of a field of a {@link Record} referred to by a field expression,
 which is a String of the form <code>@{fieldname}</code>.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.base.FieldExpression -->
  <!-- start class com.cloudera.cdk.morphline.base.Fields -->
  <class name="Fields" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Fields"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BASE_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TIMESTAMP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MESSAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ATTACHMENT_BODY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ATTACHMENT_MIME_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ATTACHMENT_CHARSET" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ATTACHMENT_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Common record field names.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.base.Fields -->
  <!-- start class com.cloudera.cdk.morphline.base.Metrics -->
  <class name="Metrics" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Metrics"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="NUM_PROCESS_CALLS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_NOTIFY_CALLS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_RECORDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ELAPSED_TIME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Common metric names.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.base.Metrics -->
  <!-- start class com.cloudera.cdk.morphline.base.Notifications -->
  <class name="Notifications" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Notifications"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLifecycleEvents" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="notification" type="com.cloudera.cdk.morphline.api.Record"/>
    </method>
    <method name="notifyBeginTransaction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="com.cloudera.cdk.morphline.api.Command"/>
    </method>
    <method name="notifyCommitTransaction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="com.cloudera.cdk.morphline.api.Command"/>
    </method>
    <method name="notifyRollbackTransaction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="com.cloudera.cdk.morphline.api.Command"/>
    </method>
    <method name="notifyShutdown"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="com.cloudera.cdk.morphline.api.Command"/>
    </method>
    <method name="notifyStartSession"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="com.cloudera.cdk.morphline.api.Command"/>
    </method>
    <method name="containsLifecycleEvent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="notification" type="com.cloudera.cdk.morphline.api.Record"/>
      <param name="event" type="com.cloudera.cdk.morphline.base.Notifications.LifecycleEvent"/>
    </method>
    <field name="LIFE_CYLCLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Tools for notifications on the control plane.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.base.Notifications -->
  <!-- start class com.cloudera.cdk.morphline.base.Notifications.LifecycleEvent -->
  <class name="Notifications.LifecycleEvent" extends="java.lang.Enum&lt;com.cloudera.cdk.morphline.base.Notifications.LifecycleEvent&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.cloudera.cdk.morphline.base.Notifications.LifecycleEvent[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.cloudera.cdk.morphline.base.Notifications.LifecycleEvent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.cloudera.cdk.morphline.base.Notifications.LifecycleEvent -->
  <!-- start class com.cloudera.cdk.morphline.base.Validator -->
  <class name="Validator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Validator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="validateRange"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="value" type="T"/>
      <param name="min" type="java.lang.Comparable&lt;T&gt;"/>
      <param name="max" type="java.lang.Comparable&lt;T&gt;"/>
      <doc>
      <![CDATA[Validates that the given value is contained in the range [min, max]]]>
      </doc>
    </method>
    <method name="validateEnum" return="T extends java.lang.Enum&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="value" type="java.lang.String"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="choices" type="T[]"/>
      <doc>
      <![CDATA[Validates that an enum of the given type with the given value exists, and that this enum is
 contained in the given list of permitted choices; finally returns that enum object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple helper to validate user configurable parameters.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.base.Validator -->
</package>
<package name="com.cloudera.cdk.morphline.hadoop.sequencefile">
  <!-- start class com.cloudera.cdk.morphline.hadoop.sequencefile.ReadSequenceFileBuilder -->
  <class name="ReadSequenceFileBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadSequenceFileBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="OUTPUT_MEDIA_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SEQUENCE_FILE_META_DATA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONFIG_KEY_FIELD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONFIG_VALUE_FIELD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Command that emits one record per sequence file entry in the input stream of the first attachment.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.hadoop.sequencefile.ReadSequenceFileBuilder -->
</package>
<package name="com.cloudera.cdk.morphline.json">
  <!-- start class com.cloudera.cdk.morphline.json.ExtractJsonPathsBuilder -->
  <class name="ExtractJsonPathsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractJsonPathsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that uses zero or more JSON path expressions to extract values from a JSON object.
 
 The JSON input object is expected to be contained in the {@link Fields#ATTACHMENT_BODY}
 
 Each expression consists of a record output field name (on the left side of the colon ':') as
 well as zero or more path steps (on the right hand side), each path step separated by a '/'
 slash. JSON arrays are traversed with the '[]' notation.
 
 The result of a path expression is a list of objects, each of which is added to the given record
 output field.
 
 The path language supports all JSON concepts, including nested structures, records, arrays, etc,
 as well as a flatten option that collects the primitives in a subtree into a flat list.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.json.ExtractJsonPathsBuilder -->
  <!-- start class com.cloudera.cdk.morphline.json.ReadJsonBuilder -->
  <class name="ReadJsonBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadJsonBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="MIME_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The MIME type identifier that will be filled into output records]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Command that parses an InputStream that contains JSON data; for each JSON object in the stream,
 the command emits a morphline record containing the object as an attachment in
 {@link Fields#ATTACHMENT_BODY}.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.json.ReadJsonBuilder -->
</package>
<package name="com.cloudera.cdk.morphline.saxon">
  <!-- start class com.cloudera.cdk.morphline.saxon.ConvertHTMLBuilder -->
  <class name="ConvertHTMLBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ConvertHTMLBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts HTML to XHTML using the <a
 href="http://ccil.org/~cowan/XML/tagsoup/">TagSoup</a> library.
 
 Instead of parsing well-formed or valid XML, this command parses HTML as it is found in the wild:
 poor, nasty and brutish, though quite often far from short. TagSoup (and hence this command) is
 designed for people who have to process this stuff using some semblance of a rational application
 design. By providing this converter, it allows standard XML tools to be applied to even the
 worst HTML.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.saxon.ConvertHTMLBuilder -->
  <!-- start class com.cloudera.cdk.morphline.saxon.XQueryBuilder -->
  <class name="XQueryBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="XQueryBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that parses an InputStream that contains an XML document and runs the given XQuery over
 the XML document. For each item in the query result sequence, the command emits a morphline record
 containing the item's name-value pairs.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.saxon.XQueryBuilder -->
  <!-- start class com.cloudera.cdk.morphline.saxon.XSLTBuilder -->
  <class name="XSLTBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="XSLTBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that parses an InputStream that contains an XML document and runs the given XSL Transform
 over the XML document. For each item in the query result sequence, the command emits a morphline
 record containing the item's name-value pairs.
 
 TODO: Add support for streaming via fragmentPath.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.saxon.XSLTBuilder -->
</package>
<package name="com.cloudera.cdk.morphline.scriptengine.java">
  <!-- start class com.cloudera.cdk.morphline.scriptengine.java.FastJavaScriptEngine -->
  <class name="FastJavaScriptEngine" extends="javax.script.AbstractScriptEngine"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.script.Compilable"/>
    <constructor name="FastJavaScriptEngine"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compile" return="javax.script.CompiledScript"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="script" type="java.lang.String"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="parameterTypes" type="java.lang.Class[]"/>
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </method>
    <method name="compile" return="javax.script.CompiledScript"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="script" type="java.lang.String"/>
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </method>
    <method name="compile" return="javax.script.CompiledScript"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </method>
    <method name="eval" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="ctx" type="javax.script.ScriptContext"/>
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </method>
    <method name="eval" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="ctx" type="javax.script.ScriptContext"/>
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </method>
    <method name="getFactory" return="javax.script.ScriptEngineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createBindings" return="javax.script.Bindings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is a fast script engine for Java programming language - I modified JSR
 223 Java Scripting a little for some 100x less overhead for invoking "static" methods.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.scriptengine.java.FastJavaScriptEngine -->
  <!-- start class com.cloudera.cdk.morphline.scriptengine.java.FastJavaScriptEngine.JavaCompiledScript -->
  <class name="FastJavaScriptEngine.JavaCompiledScript" extends="javax.script.CompiledScript"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="eval" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="params" type="java.lang.Object[]"/>
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </method>
    <method name="getEngine" return="javax.script.ScriptEngine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="eval" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ctx" type="javax.script.ScriptContext"/>
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </method>
  </class>
  <!-- end class com.cloudera.cdk.morphline.scriptengine.java.FastJavaScriptEngine.JavaCompiledScript -->
  <!-- start class com.cloudera.cdk.morphline.scriptengine.java.JavaScriptEngineFactory -->
  <class name="JavaScriptEngineFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.script.ScriptEngineFactory"/>
    <constructor name="JavaScriptEngineFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEngineName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEngineVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExtensions" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLanguageName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLanguageVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMethodCallSyntax" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.String"/>
      <param name="m" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="getMimeTypes" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNames" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOutputStatement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toDisplay" type="java.lang.String"/>
    </method>
    <method name="getParameter" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <method name="getProgram" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statements" type="java.lang.String[]"/>
    </method>
    <method name="getScriptEngine" return="javax.script.ScriptEngine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is script engine factory for "Java" script engine.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.scriptengine.java.JavaScriptEngineFactory -->
  <!-- start class com.cloudera.cdk.morphline.scriptengine.java.ScriptEvaluator -->
  <class name="ScriptEvaluator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ScriptEvaluator" type="java.lang.String, java.lang.String, java.lang.Class&lt;T&gt;, java.lang.String[], java.lang.Class[], java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </constructor>
    <method name="evaluate" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="params" type="java.lang.Object[]"/>
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </method>
    <doc>
    <![CDATA[Creates and compiles the given Java code block, wrapped into a Java method with the given return
 type and parameter types, along with a Java class definition that contains the given import
 statements.
 <p>
 Compilation is done in main memory, i.e. without writing to the filesystem.
 <p>
 The result is an object that can be executed (and reused) any number of times. This is a high
 performance implementation, using an optimized variant of https://scripting.dev.java.net/" (JSR
 223 Java Scripting). Calling {@link #evaluate(Object...)} just means calling
 {@link Method#invoke(Object, Object...)} and as such has the same minimal runtime cost, i.e.
 O(100M calls/sec/core).
 
 Instances of this class are thread-safe if the user provided script statements are thread-safe.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.scriptengine.java.ScriptEvaluator -->
</package>
<package name="com.cloudera.cdk.morphline.solr">
  <!-- start interface com.cloudera.cdk.morphline.solr.DocumentLoader -->
  <interface name="DocumentLoader"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="beginTransaction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Begins a transaction]]>
      </doc>
    </method>
    <method name="load"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="doc" type="org.apache.solr.common.SolrInputDocument"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Loads the given document into the destination]]>
      </doc>
    </method>
    <method name="commitTransaction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Sends any outstanding documents to the destination and waits for a positive
 or negative ack (i.e. exception). Depending on the outcome the caller
 should then commit or rollback the current flume transaction
 correspondingly.
 
 @throws IOException
           If there is a low-level I/O error.]]>
      </doc>
    </method>
    <method name="rollbackTransaction" return="org.apache.solr.client.solrj.response.UpdateResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Performs a rollback of all non-committed documents pending.
 <p>
 Note that this is not a true rollback as in databases. Content you have
 previously added may have already been committed due to autoCommit, buffer
 full, other client performing a commit etc. So this is only a best-effort
 rollback.
 
 @throws IOException
           If there is a low-level I/O error.]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Releases allocated resources]]>
      </doc>
    </method>
    <method name="ping" return="org.apache.solr.client.solrj.response.SolrPingResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Issues a ping request to check if the server is alive
 
 @throws IOException
           If there is a low-level I/O error.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A vehicle to load a list of Solr documents into some kind of destination,
 such as a SolrServer or MapReduce RecordWriter.]]>
    </doc>
  </interface>
  <!-- end interface com.cloudera.cdk.morphline.solr.DocumentLoader -->
  <!-- start class com.cloudera.cdk.morphline.solr.GenerateSolrSequenceKeyBuilder -->
  <class name="GenerateSolrSequenceKeyBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="GenerateSolrSequenceKeyBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that assigns a record unique key that is the concatenation of the given
 <code>baseIdField</code> record field, followed by a running count of the record number within
 the current session. The count is reset to zero whenever a "startSession" notification is
 received.
 <p>
 For example, assume a CSV file containing multiple records but no unique ids, and the
 <code>baseIdField</code> field is the filesystem path of the file. Now this command can be used
 to assign the following record values to Solr's unique key field:
 <code>$path#0, $path#1, ... $path#N</code>.
 <p>
 The name of the unique key field is fetched from Solr's schema.xml file, as directed by the
 <code>solrLocator</code> configuration parameter.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solr.GenerateSolrSequenceKeyBuilder -->
  <!-- start class com.cloudera.cdk.morphline.solr.LoadSolrBuilder -->
  <class name="LoadSolrBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="LoadSolrBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that loads a record into a SolrServer or MapReduce SolrOutputFormat.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solr.LoadSolrBuilder -->
  <!-- start class com.cloudera.cdk.morphline.solr.SanitizeUnknownSolrFieldsBuilder -->
  <class name="SanitizeUnknownSolrFieldsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="SanitizeUnknownSolrFieldsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that sanitizes record fields that are unknown to Solr schema.xml by either deleting them
 (renameToPrefix is absent or a zero length string), or by moving them to a field prefixed with
 the given renameToPrefix (e.g. renameToPrefix = "ignored_" to use typical dynamic Solr fields).
 <p>
 Recall that Solr throws an exception on any attempt to load a document that contains a field that
 isn't specified in schema.xml.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solr.SanitizeUnknownSolrFieldsBuilder -->
  <!-- start class com.cloudera.cdk.morphline.solr.SolrLocator -->
  <class name="SolrLocator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SolrLocator" type="com.cloudera.cdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SolrLocator" type="com.typesafe.config.Config, com.cloudera.cdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLoader" return="com.cloudera.cdk.morphline.solr.DocumentLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIndexSchema" return="org.apache.solr.schema.IndexSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toConfig" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <method name="getCollectionName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCollectionName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collectionName" type="java.lang.String"/>
    </method>
    <method name="getZkHost" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setZkHost"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="zkHost" type="java.lang.String"/>
    </method>
    <method name="getSolrHomeDir" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setSolrHomeDir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="solrHomeDir" type="java.lang.String"/>
    </method>
    <method name="getServerUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setServerUrl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="solrUrl" type="java.lang.String"/>
    </method>
    <method name="getBatchSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setBatchSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="batchSize" type="int"/>
    </method>
    <doc>
    <![CDATA[Set of configuration parameters that identify the location and schema of a Solr server or
 SolrCloud; Based on this information this class can return the schema and a corresponding
 {@link DocumentLoader}.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solr.SolrLocator -->
  <!-- start class com.cloudera.cdk.morphline.solr.SolrMorphlineContext -->
  <class name="SolrMorphlineContext" extends="com.cloudera.cdk.morphline.api.MorphlineContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SolrMorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[For public access use {@link Builder#build()} instead]]>
      </doc>
    </constructor>
    <method name="getDocumentLoader" return="com.cloudera.cdk.morphline.solr.DocumentLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIndexSchema" return="org.apache.solr.schema.IndexSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A context that is specific to Solr.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solr.SolrMorphlineContext -->
  <!-- start class com.cloudera.cdk.morphline.solr.SolrMorphlineContext.Builder -->
  <class name="SolrMorphlineContext.Builder" extends="com.cloudera.cdk.morphline.api.MorphlineContext.Builder"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SolrMorphlineContext.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setDocumentLoader" return="com.cloudera.cdk.morphline.solr.SolrMorphlineContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="com.cloudera.cdk.morphline.solr.DocumentLoader"/>
    </method>
    <method name="setIndexSchema" return="com.cloudera.cdk.morphline.solr.SolrMorphlineContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.solr.schema.IndexSchema"/>
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.solr.SolrMorphlineContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="create" return="com.cloudera.cdk.morphline.solr.SolrMorphlineContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Helper to construct a {@link SolrMorphlineContext} instance.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solr.SolrMorphlineContext.Builder -->
  <!-- start class com.cloudera.cdk.morphline.solr.SolrServerDocumentLoader -->
  <class name="SolrServerDocumentLoader" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.solr.DocumentLoader"/>
    <constructor name="SolrServerDocumentLoader" type="org.apache.solr.client.solrj.SolrServer, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="beginTransaction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="load"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="doc" type="org.apache.solr.common.SolrInputDocument"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
    </method>
    <method name="commitTransaction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rollbackTransaction" return="org.apache.solr.client.solrj.response.UpdateResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="ping" return="org.apache.solr.client.solrj.response.SolrPingResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getSolrServer" return="org.apache.solr.client.solrj.SolrServer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A vehicle to load a list of Solr documents into a local or remote {@link SolrServer}.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solr.SolrServerDocumentLoader -->
  <!-- start class com.cloudera.cdk.morphline.solr.TokenizeTextBuilder -->
  <class name="TokenizeTextBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="TokenizeTextBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that uses the embedded Solr/Lucene Analyzer library to generate tokens from a text
 string, without sending data to a Solr server.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solr.TokenizeTextBuilder -->
</package>
<package name="com.cloudera.cdk.morphline.solrcell">
  <!-- start class com.cloudera.cdk.morphline.solrcell.SolrCellBuilder -->
  <class name="SolrCellBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="SolrCellBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that pipes the first attachment of a record into one of the given Tika parsers, then maps
 the Tika output back to a record using SolrCell.
 <p>
 The Tika parser is chosen from the configurable list of parsers, depending on the MIME type
 specified in the input record. Typically, this requires an upstream DetectMimeTypeBuilder
 in a prior command.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solrcell.SolrCellBuilder -->
  <!-- start class com.cloudera.cdk.morphline.solrcell.StripNonCharSolrContentHandlerFactory -->
  <class name="StripNonCharSolrContentHandlerFactory" extends="org.apache.solr.handler.extraction.SolrContentHandlerFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StripNonCharSolrContentHandlerFactory" type="java.util.Collection&lt;java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createSolrContentHandler" return="org.apache.solr.handler.extraction.SolrContentHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metadata" type="org.apache.tika.metadata.Metadata"/>
      <param name="params" type="org.apache.solr.common.params.SolrParams"/>
      <param name="schema" type="org.apache.solr.schema.IndexSchema"/>
    </method>
    <doc>
    <![CDATA[SolrContentHandler and associated factory that strips non-characters anhd trims on output.
 This prevents exceptions on parsing integer fields inside Solr server.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solrcell.StripNonCharSolrContentHandlerFactory -->
  <!-- start class com.cloudera.cdk.morphline.solrcell.TrimSolrContentHandlerFactory -->
  <class name="TrimSolrContentHandlerFactory" extends="org.apache.solr.handler.extraction.SolrContentHandlerFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TrimSolrContentHandlerFactory" type="java.util.Collection&lt;java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createSolrContentHandler" return="org.apache.solr.handler.extraction.SolrContentHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metadata" type="org.apache.tika.metadata.Metadata"/>
      <param name="params" type="org.apache.solr.common.params.SolrParams"/>
      <param name="schema" type="org.apache.solr.schema.IndexSchema"/>
    </method>
    <doc>
    <![CDATA[SolrContentHandler and associated factory that trims field values on output.
 This prevents exceptions on parsing integer fields inside Solr server.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.solrcell.TrimSolrContentHandlerFactory -->
</package>
<package name="com.cloudera.cdk.morphline.stdio">
  <!-- start class com.cloudera.cdk.morphline.stdio.AbstractParser -->
  <class name="AbstractParser" extends="com.cloudera.cdk.morphline.base.AbstractCommand"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractParser" type="com.typesafe.config.Config, com.cloudera.cdk.morphline.api.Command, com.cloudera.cdk.morphline.api.Command, com.cloudera.cdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addSupportedMimeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="mediaType" type="java.lang.String"/>
    </method>
    <method name="doProcess" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="com.cloudera.cdk.morphline.api.Record"/>
    </method>
    <method name="doProcess" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="com.cloudera.cdk.morphline.api.Record"/>
      <param name="stream" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="incrementNumRecords"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="detectCharset" return="java.nio.charset.Charset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="com.cloudera.cdk.morphline.api.Record"/>
      <param name="charset" type="java.nio.charset.Charset"/>
    </method>
    <method name="removeAttachments"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="outputRecord" type="com.cloudera.cdk.morphline.api.Record"/>
    </method>
    <field name="SUPPORTED_MIME_TYPES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Base class for convenient implementation of morphline parsers.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdio.AbstractParser -->
  <!-- start class com.cloudera.cdk.morphline.stdio.ReadClobBuilder -->
  <class name="ReadClobBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadClobBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that emits one record for the entire input stream of the first attachment, interpreting
 the stream as a Character Large Object (CLOB).]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdio.ReadClobBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdio.ReadCSVBuilder -->
  <class name="ReadCSVBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadCSVBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that extracts zero or more records from the input stream of the first attachment, 
 representing a Comma Separated Values (CSV) file.
 
 For the format see http://www.creativyst.com/Doc/Articles/CSV/CSV01.htm.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdio.ReadCSVBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdio.ReadLineBuilder -->
  <class name="ReadLineBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadLineBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that emits one record per line in the input stream of the first attachment.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdio.ReadLineBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdio.ReadMultiLineBuilder -->
  <class name="ReadMultiLineBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadMultiLineBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Multiline log parser that collapse multiline messages into a single record; supports "regex",
 "what" and "negate" configuration parameters similar to logstash.
 
 For example, this can be used to parse log4j with stack traces. Also see
 https://gist.github.com/smougenot/3182192 and http://logstash.net/docs/1.1.12/filters/multiline]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdio.ReadMultiLineBuilder -->
</package>
<package name="com.cloudera.cdk.morphline.stdlib">
  <!-- start class com.cloudera.cdk.morphline.stdlib.AbstractFieldTransformCommand -->
  <class name="AbstractFieldTransformCommand" extends="com.cloudera.cdk.morphline.base.AbstractCommand"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractFieldTransformCommand" type="com.typesafe.config.Config, com.cloudera.cdk.morphline.api.Command, com.cloudera.cdk.morphline.api.Command, com.cloudera.cdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doProcess" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="com.cloudera.cdk.morphline.api.Record"/>
    </method>
    <method name="transformFieldValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Transforms the given input value to some output value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Base class for convenient implementation of commands that do in-place updates on a field.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.AbstractFieldTransformCommand -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.AddCurrentTimeBuilder -->
  <class name="AddCurrentTimeBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="AddCurrentTimeBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="FIELD_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PRESERVE_EXISTING_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A command that adds the result of {@link System#currentTimeMillis()} to a given output field.
 
 Typically, a <tt>convertTimestamp</tt> command is subsequently used to convert this timestamp to
 an application specific output format.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.AddCurrentTimeBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.AddLocalHostBuilder -->
  <class name="AddLocalHostBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="AddLocalHostBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="FIELD_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PRESERVE_EXISTING_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USE_IP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A command that adds the name or IP of the local host to a given output field.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.AddLocalHostBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.AddValuesBuilder -->
  <class name="AddValuesBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="AddValuesBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[For each input field value, add the value to the given record output field.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.AddValuesBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.AddValuesIfAbsentBuilder -->
  <class name="AddValuesIfAbsentBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="AddValuesIfAbsentBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[For each input field value, add the value to the given record output field if the value isn't
 already contained in that field.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.AddValuesIfAbsentBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.CallParentPipeBuilder -->
  <class name="CallParentPipeBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="CallParentPipeBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that routes records to the enclosing pipe morphline object.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.CallParentPipeBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.ContainsBuilder -->
  <class name="ContainsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ContainsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that succeeds if one of the field values of the given named field is equal to one of the
 the given values, and fails otherwise; Multiple fields can be named, in which case the results
 are ANDed.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.ContainsBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.ConvertTimestampBuilder -->
  <class name="ConvertTimestampBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ConvertTimestampBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts the timestamps in a given field from one of a set of input date formats (in
 an input timezone) to an output date format (in an output timezone), while respecting daylight
 savings time rules. Provides reasonable defaults for common use cases.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.ConvertTimestampBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.DecodeBase64Builder -->
  <class name="DecodeBase64Builder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="DecodeBase64Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts a Base64 encoded String to a byte[] per Section <cite>6.8. Base64
 Content-Transfer-Encoding</cite> of <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.DecodeBase64Builder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.DropRecordBuilder -->
  <class name="DropRecordBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="DropRecordBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that silently consumes records without ever emitting any record - think /dev/null.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.DropRecordBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.EqualsBuilder -->
  <class name="EqualsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="EqualsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that succeeds if all field values of the given named fields are equal to the the given
 values, and fails otherwise.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.EqualsBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.ExtractURIComponentBuilder -->
  <class name="ExtractURIComponentBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractURIComponentBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that extracts a subcomponent from the URIs contained in the given input field and
 appends it to the given output fields.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.ExtractURIComponentBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.ExtractURIComponentsBuilder -->
  <class name="ExtractURIComponentsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractURIComponentsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that extracts subcomponents from the URIs contained in the given input field and
 appends them to output fields with the given prefix, namely scheme, authority, host, port, path,
 query, fragment, schemeSpecificPart, userInfo.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.ExtractURIComponentsBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.ExtractURIQueryParametersBuilder -->
  <class name="ExtractURIQueryParametersBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractURIQueryParametersBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that extracts the query parameters with a given name from the URIs contained in the
 given input field and appends them to the given output field.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.ExtractURIQueryParametersBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.FindReplaceBuilder -->
  <class name="FindReplaceBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="FindReplaceBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that examines each string value in a given field and replaces each substring of the string value
 that matches the given string literal or grok pattern with the given replacement.
 
 This command also supports grok dictionaries in the same way as the {@link GrokBuilder}.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.FindReplaceBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.GenerateUUIDBuilder -->
  <class name="GenerateUUIDBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="GenerateUUIDBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="FIELD_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PRESERVE_EXISTING_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PREFIX_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A command that sets a universally unique identifier on all records that are intercepted. By
 default this event header is named "id".]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.GenerateUUIDBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.GrokBuilder -->
  <class name="GrokBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="GrokBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[The Grok command uses regular expression pattern matching to extract structured fields from
 unstructured log data.
 <p>
 It is perfect for syslog logs, apache and other webserver logs, mysql logs, and in general, any
 log format that is generally written for humans and not computer consumption.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.GrokBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.IfThenElseBuilder -->
  <class name="IfThenElseBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="IfThenElseBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[An If-Then-Else command consists of a chain of zero or more conditions commands, as well as a
 chain of zero or or more commands that are processed if all conditions succeed ("then commands"),
 as well as a chain of zero or more commands that are processed if one of the conditions fails
 ("else commands").
 
 If one of the commands in the "then" chain or "else" chain fails then the entire "if" command
 fails (and the remaining commands in the "then" or "else" branch are skipped).]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.IfThenElseBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.JavaBuilder -->
  <class name="JavaBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="JavaBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[The "java" command compiles the given Java code block, wrapped into a Java method with a boolean
 return type and several parameters, along with a Java class definition that contains the given
 import statements. The code block can then be executed many times.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.JavaBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.LogDebugBuilder -->
  <class name="LogDebugBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="LogDebugBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that logs to slf4j at DEBUG level.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.LogDebugBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.LogErrorBuilder -->
  <class name="LogErrorBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="LogErrorBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that logs to slf4j at ERROR level.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.LogErrorBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.LogInfoBuilder -->
  <class name="LogInfoBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="LogInfoBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that logs to slf4j at INFO level.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.LogInfoBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.LogTraceBuilder -->
  <class name="LogTraceBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="LogTraceBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that logs to slf4j at TRACE level.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.LogTraceBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.LogWarnBuilder -->
  <class name="LogWarnBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="LogWarnBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that logs to slf4j at WARN level.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.LogWarnBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.NotBuilder -->
  <class name="NotBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="NotBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A Not command consists of one nested command, the boolean return value of which is inverted.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.NotBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.PipeBuilder -->
  <class name="PipeBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="PipeBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Factory to create morphline pipe instances.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.PipeBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.SeparateAttachmentsBuilder -->
  <class name="SeparateAttachmentsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="SeparateAttachmentsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that emits one output record for each attachment in the input record's list of
 attachments; The result is a list of records, each of which has at most one attachment.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.SeparateAttachmentsBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.SetValuesBuilder -->
  <class name="SetValuesBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="SetValuesBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[For each input field, set the given record output field to the same values.
 
 That is, first remove all values from the output field, then add new values.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.SetValuesBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.SplitBuilder -->
  <class name="SplitBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="SplitBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that divides strings into substrings, by recognizing a <i>separator</i> (a.k.a.
 "delimiter") which can be expressed as a single character, literal string, regular expression,
 {@link CharMatcher}, or by using a fixed substring length. This class provides the functionality
 of Guava's {@link Splitter} class as a morphline command.
 
 This command also supports grok dictionaries in the same way as the {@link GrokBuilder}.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.SplitBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.SplitKeyValueBuilder -->
  <class name="SplitKeyValueBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="SplitKeyValueBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that iterates over the items in a given record input field, interprets each item as a key-value
 pair where the key and value are separated by the given separator character, and adds the pair's
 value to the record field named after the pair's key.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.SplitKeyValueBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.ToByteArrayBuilder -->
  <class name="ToByteArrayBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ToByteArrayBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts the Java objects in a given field via <code>Object.toString()</code> to
 their string representation, and then via <code>String.getBytes(Charset)</code> to their byte
 array representation. If the input Java objects are already byte arrays the command does nothing.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.ToByteArrayBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.ToStringBuilder -->
  <class name="ToStringBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ToStringBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts the Java objects in a given field via <code>Object.toString()</code> to
 their string representation, and optionally also applies <code>String.trim()</code>.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.ToStringBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.TranslateBuilder -->
  <class name="TranslateBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="TranslateBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that examines each string value in a given field and replaces it with the replacement
 value defined in a given dictionary aka hash table.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.TranslateBuilder -->
  <!-- start class com.cloudera.cdk.morphline.stdlib.TryRulesBuilder -->
  <class name="TryRulesBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="TryRulesBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A tryRules command consists of zero or more rules.
 
 A rule consists of zero or more commands.
 
 The rules of a tryRules command are processed in top-down order. If one of the commands in a rule
 fails, the tryRules command stops processing of this rule, backtracks and tries the next rule,
 and so on, until a rule is found that runs all its commands to completion without failure (the
 rule succeeds). If a rule succeeds the remaining rules of the current tryRules command are
 skipped. If no rule succeeds the record remains unchanged, but a warning may be issued (the
 warning can be turned off) or an exception may be thrown (which is logged and ignored in
 production mode).
 
 Because a command can itself be a tryRules command, there can be tryRules commands with commands,
 nested inside tryRules, inside tryRules, recursively. This helps to implement arbitrarily complex
 functionality for advanced usage.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.stdlib.TryRulesBuilder -->
</package>
<package name="com.cloudera.cdk.morphline.tika">
  <!-- start class com.cloudera.cdk.morphline.tika.DetectMimeTypeBuilder -->
  <class name="DetectMimeTypeBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="DetectMimeTypeBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that auto-detects the MIME type of the first attachment, if no MIME type is defined yet.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.tika.DetectMimeTypeBuilder -->
</package>
<package name="com.cloudera.cdk.morphline.tika.decompress">
  <!-- start class com.cloudera.cdk.morphline.tika.decompress.DecompressBuilder -->
  <class name="DecompressBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="DecompressBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that decompresses the first attachment. Implementation adapted from Tika CompressorParser.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.tika.decompress.DecompressBuilder -->
  <!-- start class com.cloudera.cdk.morphline.tika.decompress.UnpackBuilder -->
  <class name="UnpackBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="UnpackBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that unpacks the first attachment. Implementation adapted from Tika PackageParser.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.tika.decompress.UnpackBuilder -->
</package>
<package name="com.cloudera.cdk.morphline.twitter">
  <!-- start class com.cloudera.cdk.morphline.twitter.ReadJsonTestTweetsBuilder -->
  <class name="ReadJsonTestTweetsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.cloudera.cdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadJsonTestTweetsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.cloudera.cdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="child" type="com.cloudera.cdk.morphline.api.Command"/>
      <param name="context" type="com.cloudera.cdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[JSON parser that extracts search documents from twitter tweets obtained from the twitter 1% sample firehose with the delimited=length option.
 For background see https://dev.twitter.com/docs/api/1.1/get/statuses/sample.
 
 The JSON input format is documented at https://dev.twitter.com/docs/platform-objects/tweets]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.morphline.twitter.ReadJsonTestTweetsBuilder -->
</package>
<package name="com.cloudera.cdk.tools">
  <!-- start class com.cloudera.cdk.tools.CombinedLogFormatConverter -->
  <class name="CombinedLogFormatConverter" extends="org.apache.crunch.util.CrunchTool"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CombinedLogFormatConverter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[A tool for converting files in
 <a href="http://en.wikipedia.org/wiki/Common_Log_Format">Combined Log Format</a> to a
 {@link com.cloudera.cdk.data.Dataset}.]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.tools.CombinedLogFormatConverter -->
  <!-- start class com.cloudera.cdk.tools.JobClasspathHelper -->
  <class name="JobClasspathHelper" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JobClasspathHelper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="prepareClasspath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="libDir" type="org.apache.hadoop.fs.Path"/>
      <param name="classesToInclude" type="java.lang.Class[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[@param conf
            Configuration object for the Job. Used to get the FileSystem associated with it.
 @param libDir
            Destination directory in the FileSystem (Usually HDFS) where to upload and look for the libs.
 @param classesToInclude
            Classes that are needed by the job. JarFinder will look for the jar containing these classes.
 @throws Exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 This class is an helper to copy the jars needed by the job in the Distributed cache.
 </p>
 
 <p>
 This tool helps to setup the job classpath at runtime. It allows library sharing between job. That result in faster
 jobs setup (since most of the time the libs are already uploaded in HDFS). Before submitting a job, you use this tool
 to provide the classes that you use in your job.
 </p>
 
 <p>
 The tool will find the jar(s), or will create the jars and upload them to a "library" path in HDFS, and it will
 create an md5 file along the uploaded jar.
 </p>
 
 <p>
 In order to find the jar or creating the job's Jar It use a modified version of org.apache.hadoop.util.JarFinder that
 is found in Hadoop 0.23
 </p>
 
 <p>
 If another job needs the same jar and provide the same "library" path it will discover it and use it, without having
 to lose the time that the upload of the jar would require.
 </p>
 
 <p>
 If the jar does not exist in the "library" path, it will upload it. However, if the jar is already in the "library"
 path, the tool will compute the md5 of the jar and compare with the one found in HDFS, and if there's a difference,
 the jar will be uploaded.
 </p>
 
 <p>
 If it creates a jar (from the classes of the job itself or from the classes in your workspace for example), it will
 upload the created jar to the "library" path and clean them after the JVM exits.
 </p>
 
 <p>
 Here's an example for a job class TestTool.class that requires HashFunction from Guava.
 </p>
 
 <pre>
 {@code
 new JobClasspathHelper().prepareClasspath(getConf(), new Path("/lib/path"), new Class[] { TestTool.class, HashFunction.class});
 }
 </pre>
 
 @author tbussier (tony.bussieres@ticksmith.com)
 @since 0.3.0]]>
    </doc>
  </class>
  <!-- end class com.cloudera.cdk.tools.JobClasspathHelper -->
</package>

</api>
