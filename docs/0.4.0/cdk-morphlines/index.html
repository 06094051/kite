<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia at 2013-06-22
 | Rendered using Apache Maven Fluido Skin 1.3.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20130622" />
    <meta http-equiv="Content-Language" content="en" />
    <title>CDK Morphlines Parent - </title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.3.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido-1.3.0.min.js"></script>

    
            </head>
        <body class="topBarDisabled">
          
    
    
            
    
        
    <a href="http://github.com/cloudera/cdk">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index: 10000;"
        src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"
        alt="Fork me on GitHub">
    </a>
  
                
                    
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>CDK Morphlines Parent</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                  <li id="publishDate">Last Published: 2013-06-22</li>
                  <li class="divider">|</li> <li id="projectVersion">Version: 0.4.0</li>
                      
                
                    
      
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span3">
          <div class="well sidebar-nav">
                
                    
                <ul class="nav nav-list">
                    <li class="nav-header">CDK</li>
                                
      <li>
    
                          <a href="../index.html" title="Home">
          <i class="none"></i>
        Home</a>
            </li>
                  
      <li>
    
                          <a href="../release_notes.html" title="Release Notes">
          <i class="none"></i>
        Release Notes</a>
            </li>
                  
      <li>
    
                          <a href="../apidocs/index.html" title="Javadoc">
          <i class="none"></i>
        Javadoc</a>
            </li>
                  
      <li>
    
                          <a href="../jdiff/changes.html" title="API Diffs">
          <i class="none"></i>
        API Diffs</a>
            </li>
                  
      <li>
    
                          <a href="../dependencies.html" title="Dependency Information">
          <i class="none"></i>
        Dependency Information</a>
            </li>
                  
      <li>
    
                          <a href="http://github.com/cloudera/cdk-examples" class="externalLink" title="Examples">
          <i class="none"></i>
        Examples</a>
            </li>
                  
      <li>
    
                          <a href="http://github.com/cloudera/cdk" class="externalLink" title="Source Repository">
          <i class="none"></i>
        Source Repository</a>
            </li>
                  
      <li>
    
                          <a href="https://issues.cloudera.org/browse/CDK" class="externalLink" title="JIRA">
          <i class="none"></i>
        JIRA</a>
            </li>
                  
      <li>
    
                          <a href="../how_to_contribute.html" title="How To Contribute">
          <i class="none"></i>
        How To Contribute</a>
            </li>
                  
      <li>
    
                          <a href="../adding_a_module.html" title="Adding a Module">
          <i class="none"></i>
        Adding a Module</a>
            </li>
                  
      <li>
    
                          <a href="../project-info.html" title="Project Information">
          <i class="none"></i>
        Project Information</a>
            </li>
                              <li class="nav-header">Modules</li>
                                
      <li>
    
                          <a href="../cdk-data/index.html" title="CDK Data">
          <i class="none"></i>
        CDK Data</a>
            </li>
                  
      <li>
    
                          <a href="../cdk-morphlines/index.html" title="CDK Morphlines">
          <i class="none"></i>
        CDK Morphlines</a>
            </li>
                  
      <li>
    
                          <a href="../cdk-tools/index.html" title="CDK Tools">
          <i class="none"></i>
        CDK Tools</a>
            </li>
                              <li class="nav-header">CDK Morphlines</li>
                                
      <li class="active">
    
            <a href="#"><i class="none"></i>Home</a>
          </li>
                  
      <li>
    
                          <a href="morphlinesReferenceGuide.html" title="Morphlines Reference Guide">
          <i class="none"></i>
        Morphlines Reference Guide</a>
            </li>
            </ul>
                
                    
                
          <hr class="divider" />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span9" >
                                  
            <div class="section">
<h2>Cloudera Morphlines<a name="Cloudera_Morphlines"></a></h2></div>
<p>Cloudera Morphlines is an open source framework that reduces the time and skills necessary to build and change Hadoop ETL stream processing applications that extract, transform and load data into Apache Solr, Enterprise Data Warehouses, HDFS, HBase or Analytic Online Dashboards.</p>
<p>A morphline is a rich configuration file that makes it easy to define an ETL transformation chain that consumes any kind of data from any kind of data source, processes the data and loads the results into a Hadoop component such as Cloudera Search. Executing in a small embeddable Java runtime system, morphlines can be used for Near Real Time applications as well as Batch processing applications.</p>
<p>Morphlines can be seen as an evolution of Unix pipelines where the data model is generalized to work with streams of generic records, including arbitrary binary payloads. Morphlines can be embedded into Hadoop components such as Search, Flume, MapReduce, Pig, Hive, and Sqoop.</p>
<p>The framework ships with a set of frequently used high level transformation and I/O commands that can be combined in application specific ways. The plugin system allows the adding of new transformations and I/O commands and integrates existing functionality and third party systems in a straightforward manner.</p>
<p>This integration enables rapid Hadoop ETL application prototyping, complex stream and event processing in real time, flexible log file analysis, integration of multiple heterogeneous input schemas and file formats, as well as reuse of ETL logic building blocks across Hadoop ETL applications.</p>
<p>The CDK ships a high performance runtime that compiles a morphline on the fly. The runtime processes all commands of a given morphline in the same thread, adding no artificial overhead. For high scalability, you can deploy many morphline instances on a cluster in many Flume agents and MapReduce tasks.</p>
<p>Currently there are three components that execute morphlines:</p>
<ul>
<li><a class="externalLink" href="http://tiny.cloudera.com/search-v1-user-guide">MapReduceIndexerTool</a></li>
<li><a class="externalLink" href="http://tiny.cloudera.com/search-v1-user-guide">Flume Morphline Solr Sink and Flume MorphlineInterceptor</a></li></ul>
<p>Morphlines manipulate continuous or arbitrarily large streams of records. The data model can be described as follows: A <i>record</i> is a set of named fields where each field has an ordered list of one or more values. A value can be any Java Object. That is, a record is essentially a hash table where each hash table entry contains a String key and a list of Java Objects as values. (The implementation uses Guava's <tt>ArrayListMultimap</tt>, which is a <tt>ListMultimap</tt>). Note that a field can have multiple values and any two records need not use common field names. This flexible data model corresponds exactly to the characteristics of the Solr/Lucene data model, meaning a record can be seen as a <tt>SolrInputDocument</tt>. A field with zero values is removed from the record  fields with zero values effectively do not exist.</p>
<p>Not only structured data, but also arbitrary binary data can be passed into and processed by a morphline. By convention, a record can contain an optional field named _attachment_body, which can be a Java <tt>java.io.InputStream</tt> or Java byte[]. Optionally, such binary input data can be characterized in more detail by setting the fields named _attachment_mimetype (such as <tt>application/pdf</tt>) and _attachment_charset (such as UTF-8) and _attachment_name (such as <tt>cars.pdf</tt>), which assists in detecting and parsing the data type.</p>
<p>This generic data model is useful to support a wide range of applications.</p>
<p>A command transforms a record into zero or more records. Commands can access all record fields. For example, commands can parse fields, set fields, remove fields, rename fields, find and replace values, split a field into multiple fields, split a field into multiple values, or drop records. Often, regular expression based pattern matching is used as part of the process of acting on fields. The output records of a command are passed to the next command in the chain. A command has a Boolean return code, indicating success or failure.</p>
<p>For example, consider the case of a multi-line input record: A command could take this multi-line input record and divide the single record into multiple output records, one for each line. This output could then later be further divided using regular expression commands, splitting each single line record out into multiple fields in application specific ways.</p>
<p>A command can extract, clean, transform, join, integrate, enrich and decorate records in many other ways. For example, a command can join records with external data sources such as relational databases, keyvalue stores, local files or IP Geo lookup tables. It can also perform tasks such as DNS resolution, expand shortened URLs, fetch linked metadata from social networks, perform sentiment analysis and annotate the record accordingly, continuously maintain statistics for analytics over sliding windows, compute exact or approximate distinct values and quantiles.</p>
<p>A command can also consume records and pass them to external systems. For example, a command can load records into Solr or write them to a MapReduce Reducer, or load them into an Enterpreise Data Warehouse or a Key Value store such as HBase, or pass them into an online dashboard, or write them to HDFS.</p>
<p>A command can contain nested commands. Thus, a morphline is a tree of commands, akin to a pushbased data flow engine or operator tree in DBMS query execution engines.</p>
<p>A morphline has no notion of persistence, durability, distributed computing, or node failover. A morphline is basically just a chain of inmemory transformations in the current thread. There is no need for a morphline to manage multiple processes, nodes, or threads because this is already addressed by host systems such as MapReduce, Flume, or Storm. However, a morphline does support passing notifications on the control plane to command subtrees. Such notifications include BEGIN_TRANSACTION, COMMIT_TRANSACTION, ROLLBACK_TRANSACTION and SHUTDOWN.</p>
<p>The morphline configuration file is implemented using the HOCON format (HumanOptimized Config Object Notation). HOCON is basically JSON slightly adjusted for the configuration file use case. HOCON syntax is defined at <a class="externalLink" href="http://github.com/typesafehub/config/blob/master/HOCON.md">HOCON github page</a> and also used by <a class="externalLink" href="http://www.akka.io">Akka</a> and <a class="externalLink" href="http://www.playframework.org/">Play</a>.</p>
<p>Cloudera Morphlines includes several maven modules that contain morphline commands for flexible log file analysis, single-line records, multi-line records, CSV files, Apache Avro and Apache Hadoop Sequence Files, regular expression based pattern matching and extraction, operations on record fields for assignment and comparison, operations on record fields with list and set semantics, if-then-else conditionals, string and timestamp conversions, scripting support for dynamic java code, a small rules engine, logging, metrics and counters, integration with Apache Solr including SolrCloud, integration with Apache SolrCell and all Apache Tika parsers, autodetection of MIME types from binary data using Apache Tika, and decompression and unpacking of arbitrarily nested container file formats, among others. These are described in detail in the <a href="morphlinesReferenceGuide.html">Morphline Reference Guide</a>.</p>
<div class="section">
<h2>Example Morphline Syslog Usage<a name="Example_Morphline_Syslog_Usage"></a></h2></div>
<p>This section provides a sample that illustrates using a morphline to index a syslog file.</p>
<div class="section">
<h4>Defining Example Input and Output<a name="Defining_Example_Input_and_Output"></a></h4></div>
<p>A syslog file contains semi-structured lines of the following form:</p>
<div class="source">
<pre>&lt;164&gt;Feb  4 10:46:14 syslog sshd[607]: listening on 0.0.0.0 port 22.
</pre></div>
<p>The program should extract the following record from the log line and load it into Solr:</p>
<div class="source">
<pre>syslog_pri:164
syslog_timestamp:Feb  4 10:46:14
syslog_hostname:syslog
syslog_program:sshd
syslog_pid:607
syslog_message:listening on 0.0.0.0 port 22.
</pre></div>
<div class="section">
<h4>Defining a Chain of Transformation Commands<a name="Defining_a_Chain_of_Transformation_Commands"></a></h4></div>
<p>These rules can be expressed with morphline commands called <a href="morphlinesReferenceGuide.html#readLine">readLine</a>, <a href="morphlinesReferenceGuide.html#grok">grok</a>, <a href="morphlinesReferenceGuide.html#convertTimestamp">convertTimestamp</a>, <a href="morphlinesReferenceGuide.html#sanitizeUnknownSolrFields">sanitizeUnknownSolrFields</a> and <a href="morphlinesReferenceGuide.html#loadSolr">loadSolr</a>, by editing a <tt>morphline.conf</tt> file to read as follows:</p>
<div class="source">
<pre># Specify server locations in a SOLR_LOCATOR variable; used later in
# variable substitutions:
SOLR_LOCATOR : {
  # Name of solr collection
  collection : collection1

  # ZooKeeper ensemble
  zkHost : &quot;127.0.0.1:2181/solr&quot;
}

# Specify an array of one or more morphlines, each of which defines an ETL
# transformation chain. A morphline consists of one or more (potentially
# nested) commands. A morphline is a way to consume records (e.g. Flume events,
# HDFS files or blocks), turn them into a stream of records, and pipe the stream
# of records through a set of easily configurable transformations on the way to
# a target application such as Solr.
morphlines : [
  {
    id : morphline1
    importCommands : [&quot;com.cloudera.**&quot;]

    commands : [
      {
        readLine {
          charset : UTF-8
        }
      }

      {
        grok {
          # a grok-dictionary is a config file that contains prefabricated regular expressions
          # that can be referred to by name.
          # grok patterns specify such a regex name, plus an optional output field name.
          # The syntax is %{REGEX_NAME:OUTPUT_FIELD_NAME}
          # The input line is expected in the &quot;message&quot; input field.
          dictionaryFiles : [target/test-classes/grok-dictionaries]
          expressions : {
            message : &quot;&quot;&quot;&lt;%{POSINT:syslog_pri}&gt;%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}&quot;&quot;&quot;
          }
        }
      }

      # Consume the output record of the previous command and pipe another
      # record downstream.
      #
      # Command that deletes record fields that are unknown to Solr
      # schema.xml.
      #
      # Recall that Solr throws an exception on any attempt to load a document
      # that contains a field that isn't specified in schema.xml.
      {
        sanitizeUnknownSolrFields {
          # Location from which to fetch Solr schema
          solrLocator : ${SOLR_LOCATOR}
        }
      }

      # log the record at DEBUG level to SLF4J
      { logDebug { format : &quot;output record: {}&quot;, args : [&quot;@{}&quot;] } }

      # load the record into a Solr server or MapReduce Reducer
      {
        loadSolr {
          solrLocator : ${SOLR_LOCATOR}
        }
      }
    ]
  }
]
</pre></div>
<div class="section">
<h2>Example Morphline Avro Usage<a name="Example_Morphline_Avro_Usage"></a></h2></div>
<p>This section provides a sample that illustrates using a morphline to index an Avro file with a given schema.</p>
<div class="section">
<h4>Viewing Avro<a name="Viewing_Avro"></a></h4></div>
<p>Let's view the content of a sample Avro file to understand the data:</p>
<div class="source">
<pre>$ wget http://archive.apache.org/dist/avro/avro-1.7.4/java/avro-tools-1.7.4.jar
$ java -jar avro-tools-1.7.4.jar tojson /usr/share/doc/search*/examples/test-documents/sample-statuses-20120906-141433.avro
</pre></div>
<div class="section">
<h4>Inspecting the Schema of the Avro file<a name="Inspecting_the_Schema_of_the_Avro_file"></a></h4></div>
<div class="source">
<pre>$ java -jar avro-tools-1.7.4.jar getschema /usr/share/doc/search*/examples/test-documents/sample-statuses-20120906-141433.avro

{
  &quot;type&quot; : &quot;record&quot;,
  &quot;name&quot; : &quot;Doc&quot;,
  &quot;doc&quot; : &quot;adoc&quot;,
  &quot;fields&quot; : [ {
    &quot;name&quot; : &quot;id&quot;,
    &quot;type&quot; : &quot;string&quot;
  }, {
    &quot;name&quot; : &quot;user_statuses_count&quot;,
    &quot;type&quot; : [ &quot;int&quot;, &quot;null&quot; ]
  }, {
    &quot;name&quot; : &quot;user_screen_name&quot;,
    &quot;type&quot; : [ &quot;string&quot;, &quot;null&quot; ]
  }, {
    &quot;name&quot; : &quot;created_at&quot;,
    &quot;type&quot; : [ &quot;string&quot;, &quot;null&quot; ]
  }, {
    &quot;name&quot; : &quot;text&quot;,
    &quot;type&quot; : [ &quot;string&quot;, &quot;null&quot; ]
  }

  ...

  ]
}
</pre></div>
<div class="section">
<h4>Defining a Sample Solr Schema<a name="Defining_a_Sample_Solr_Schema"></a></h4></div>
<p>We want to extract the fields named <tt>id</tt>, user_screen_name, created_at and <tt>text</tt> from the given Avro records, then store and index them in Solr, using the following Solr schema definition in <tt>schema.xml</tt>:</p>
<div class="source">
<pre>&lt;fields&gt;
  &lt;field name=&quot;id&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot; multiValued=&quot;false&quot; /&gt;
  &lt;field name=&quot;username&quot; type=&quot;text_en&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;
  &lt;field name=&quot;created_at&quot; type=&quot;tdate&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;
  &lt;field name=&quot;text&quot; type=&quot;text_en&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;

  &lt;field name=&quot;_version_&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;
  &lt;dynamicField name=&quot;ignored_*&quot; type=&quot;ignored&quot;/&gt;
&lt;/fields&gt;
</pre></div>
<p>Note that the Solr output schema omits some Avro input fields such as user_statuses_count. Suppose you want to rename the input field user_screen_name to the output field <tt>username</tt>. Also suppose that the time format for the created_at field is yyyyMM-dd'T'HH:mm:ss'Z'. Finally, suppose any unknown fields present are to be removed. Recall that Solr throws an exception on any attempt to load a document that contains a field that is not specified in <tt>schema.xml</tt>.</p>
<div class="section">
<h4>Defining a Chain of Transformation Commands<a name="Defining_a_Chain_of_Transformation_Commands"></a></h4></div>
<p>These transformation rules can be expressed with morphline commands called <a href="morphlinesReferenceGuide.html#readAvroContainer">readAvroContainer</a>, <a href="morphlinesReferenceGuide.html#extractAvroPaths">extractAvroPaths</a>, <a href="morphlinesReferenceGuide.html#convertTimestamp">convertTimestamp</a>, <a href="morphlinesReferenceGuide.html#sanitizeUnknownSolrFields">sanitizeUnknownSolrFields</a> and <a href="morphlinesReferenceGuide.html#loadSolr">loadSolr</a>, by editing a <tt>morphline.conf</tt> file to read as follows:</p>
<div class="source">
<pre># Specify server locations in a SOLR_LOCATOR variable; used later in
# variable substitutions:
SOLR_LOCATOR : {
  # Name of solr collection
  collection : collection1

  # ZooKeeper ensemble
  zkHost : &quot;127.0.0.1:2181/solr&quot;
}

# Specify an array of one or more morphlines, each of which defines an ETL
# transformation chain. A morphline consists of one or more (potentially
# nested) commands. A morphline is a way to consume records (e.g. Flume events,
# HDFS files or blocks), turn them into a stream of records, and pipe the stream
# of records through a set of easily configurable transformations on the way to
# a target application such as Solr.
morphlines : [
  {
    # Name used to identify a morphline. E.g. used if there are multiple
    # morphlines in a morphline config file
    id : morphline1

    # Import all morphline commands in these java packages and their subpackages.
    # Other commands that may be present on the classpath are not visible to this
    # morphline.
    importCommands : [&quot;com.cloudera.**&quot;, &quot;org.apache.solr.**&quot;]

    commands : [
      {
        # Parse Avro container file and emit a record for each Avro object
        readAvroContainer {
          # Optionally, require the input to match one of these MIME types:
          # supportedMimeTypes : [avro/binary]

          # Optionally, use a custom Avro schema in JSON format inline:
          # readerSchemaString : &quot;&quot;&quot;&lt;json can go here&gt;&quot;&quot;&quot;

          # Optionally, use a custom Avro schema file in JSON format:
          # readerSchemaFile : /path/to/syslog.avsc
        }
      }

      {
        # Consume the output record of the previous command and pipe another
        # record downstream.
        #
        # extractAvroPaths is a command that uses zero or more Avro path
        # expressions to extract values from an Avro object. Each expression
        # consists of a record output field name (on the left side of the
        # colon ':') as well as zero or more path steps (on the right hand
        # side), each path step separated by a '/' slash. Avro arrays are
        # traversed with the '[]' notation.
        #
        # The result of a path expression is a list of objects, each of which
        # is added to the given record output field.
        #
        # The path language supports all Avro concepts, including nested
        # structures, records, arrays, maps, unions, etc, as well as a flatten
        # option that collects the primitives in a subtree into a flat list.
        extractAvroPaths {
          flatten : false
          paths : {
            id : /id
            username : /user_screen_name
            created_at : /created_at
            text : /text
          }
        }
      }

      # Consume the output record of the previous command and pipe another
      # record downstream.
      #
      # convert timestamp field to native Solr timestamp format
      # e.g. 2012-09-06T07:14:34Z to 2012-09-06T07:14:34.000Z
      {
        convertTimestamp {
          field : created_at
          inputFormats : [&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, &quot;yyyy-MM-dd&quot;]
          inputTimezone : America/Los_Angeles
          outputFormat : &quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;
          outputTimezone : UTC
        }
      }

      # Consume the output record of the previous command and pipe another
      # record downstream.
      #
      # Command that deletes record fields that are unknown to Solr
      # schema.xml.
      #
      # Recall that Solr throws an exception on any attempt to load a document
      # that contains a field that isn't specified in schema.xml.
      {
        sanitizeUnknownSolrFields {
          # Location from which to fetch Solr schema
          solrLocator : ${SOLR_LOCATOR}
        }
      }

      # log the record at DEBUG level to SLF4J
      { logDebug { format : &quot;output record: {}&quot;, args : [&quot;@{}&quot;] } }

      # load the record into a Solr server or MapReduce Reducer
      {
        loadSolr {
          solrLocator : ${SOLR_LOCATOR}
        }
      }
    ]
  }
]
</pre></div>
<div class="section">
<h2>Next Steps<a name="Next_Steps"></a></h2></div>
<dl>
<dd>More example morphline configuration files can be found in the <a class="externalLink" href="https://github.com/cloudera/cdk/tree/master/cdk-morphlines/cdk-morphlines-core/src/test/resources/test-morphlines">unit tests</a>.</dd></dl>
<dl>
<dd>A detailed description of all morphline commands can be found in the <a href="morphlinesReferenceGuide.html">Morphlines Reference Guide</a>.</dd></dl>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
              <div class="row span12">Copyright &copy;                    2013
                        <a href="http://www.cloudera.com">Cloudera</a>.
            All Rights Reserved.      
                    
      </div>

        
        
                </div>
    </footer>
  </body>
</html>
